本周阅读**Database-System-Concepts-7th-Edition**:PART SIX QUERY PROCESSING AND OPTIMIZATION,知识点总结如下：  
**Chapter 15 Query Processing**(p689-740)  
>日期：5.27

# 第15章 查询处理

## 15.1 概述
查询处理指从数据库中提取数据所涉及的一系列活动。这些活动包括将高级数据库语言编写的查询，转换为可在文件系统物理层面使用的表达式、进行各种查询优化转换，以及对查询进行实际评估。
查询处理的基本步骤如下：
1. **解析与转换**：将查询（如SQL）转换为基于扩展关系代数的内部形式。解析器会检查用户查询的语法，验证查询中出现的关系名称是否为数据库中的关系名等。系统构建查询的语法树表示，然后将其转换为关系代数表达式。若查询基于视图表示，转换阶段还会用定义视图的关系代数表达式替换所有视图引用。
2. **优化**：构建能使查询评估成本最小化的查询评估计划。 
3. **评估**：执行查询评估计划并返回结果。 

## 15.2 查询成本度量
- **成本构成**：查询评估成本可从磁盘访问、CPU时间以及（在并行和分布式系统中的）通信成本等方面衡量。对于大型磁盘数据库，I/O成本通常占主导。随着闪存存储（固态硬盘，SSDs）的兴起和主内存容量增大，CPU成本也需纳入考量。 
- **成本估算因素**： 
    - 我们使用从存储中传输的块数（ $b$ ）和随机I/O访问次数（ $S$ ）。一次操作所需时间为 $b * t_T+S * t_S$ ，其中 $t_T$ 是传输一块数据的时间， $t_S$ 是平均块访问时间（对于磁盘，是磁盘寻道时间加上旋转延迟 ）。
    - 2018年高端磁盘的典型值为 $t_S = 4$ 毫秒， $t_T = 0.1$ 毫秒（假设块大小为4KB，传输速率为每秒40MB ）。 
    - 2018年使用SATA接口的中端SSD， $t_S$ 约为90微秒，对于4KB的块， $t_T$  约为10微秒。使用PCIe 3.0 x4接口的SSD， $t_S$ 更小（20 - 60微秒），传输速率更高（ $t_T$ 为2微秒 ）。 
    - 对于主内存中的数据，传输4KB块的时间 $t_T$ 小于1微秒，获取数据的延迟  $t_S$ 小于100纳秒。 
- **缓冲区影响**：算法成本取决于主内存中缓冲区的大小。在PostgreSQL中，出于成本估算目的，查询的有效缓存大小（查询可用的总内存）默认假定为4GB。若多个操作符并发运行，可用内存将在它们之间分配。为考虑缓冲区驻留情况，PostgreSQL假定随机页面读取成本为实际成本的1/10，以模拟90%的缓存命中率。 
- **响应时间与资源消耗**：响应时间（执行计划的实际时间）难以估算，因为它取决于查询开始时缓冲区的内容，以及多磁盘系统中的磁盘访问分布情况。因此，优化器通常旨在最小化查询计划的总资源消耗，比如估算总磁盘访问时间（包括寻道和数据传输 ）。 

## 15.3 选择操作
- **文件扫描**：在查询处理中，文件扫描是访问数据的最底层操作符。它是一种搜索算法，用于定位和检索满足选择条件的记录。在关系系统中，当关系存储在单个文件中时，可使用文件扫描读取整个关系。 
- **使用文件扫描和索引的选择操作**： 
    - **A1（线性搜索）**：扫描每个文件块，并测试所有记录是否满足选择条件。需要初始寻道来访问文件的第一个块。尽管它可能比其他实现选择操作的算法慢，但无论文件顺序、索引可用性或选择操作的性质如何，都可应用于任何文件。 

SQL查询示例：
```sql
select salary
from instructor
where salary < 75000;
```
此查询可转换为以下关系代数表达式：
- $\sigma_{salary<75000} (\Pi_{salary} (instructor))$
- $\Pi_{salary} (\sigma_{salary<75000} (instructor))$ 

### 15.3 选择操作
- **文件扫描基础**：文件扫描是查询处理中访问数据的底层操作符，用于定位和检索满足选择条件的记录。在关系系统中，当关系存储在单个文件时可使用。
- **选择算法及成本估算**
    - **A1（线性搜索）**
        - **一般情况**：成本公式为  $t_S + b_r * t_T$  。需一次初始寻道加上  $b_r$  次块传输 ， $b_r$  是文件中的块数。
        - **键上相等条件平均情况**：成本公式为  $t_S+(b_r/2) * t_T$  。因为最多只有一条记录满足条件，找到所需记录后扫描可终止，平均需扫描一半块 ，但最坏情况仍需传输  $b_r$  个块。
    - **A2（聚簇索引，键上相等）**：利用聚簇索引检索满足键相等条件的单个记录。成本公式为  $(h_i + 1) * (t_T + t_S)$  ， $h_i$  是索引树高度 。索引查找需遍历树高对应层数再加一次I/O获取记录，每次I/O操作包含一次寻道和一次块传输。为模拟索引内部节点在内存缓冲区的常见情况，可设  $h_i = 1$  。
    - **A3（聚簇索引，非键上相等）**：用聚簇索引检索满足非键属性相等选择条件的多个记录。记录在文件中按搜索键顺序存储。成本公式为  $h_i * (t_T + t_S) + t_S + b * t_T$  ， $h_i$  是索引树高度， $b$  是包含指定搜索键记录的块数 。需对树的每一层进行一次寻道，加上获取第一个块的寻道，然后读取包含记录的块。
    - **A4（辅助索引，相等）**
        - **键上相等**：检索单个记录，成本与聚簇索引情况A2相同，即  $(h_i + 1) * (t_T + t_S)$  。
        - **非键上相等**：可能检索多个记录，每个记录可能在不同块，每次I/O操作需寻道和块传输。最坏情况成本公式为 $(h_i + n) * (t_S + t_T)$ ， $n$ 是获取的记录数 。若内存缓冲区大，记录所在块可能已在缓冲区，可通过考虑记录在缓冲区的概率来估算平均成本，此时成本会远低于最坏情况。
    - **A5（聚簇索引，比较）**
        - 对于  $A \geq v$  或  $A > v$   形式的比较条件，使用聚簇索引定位满足条件的元组。成本估算与A3相同。如  $A \geq v$  时，从索引查找第一个  $A \geq v$ 的元组，然后从该元组开始扫描文件； $A > v$ 时，从第一个 $A > v$  的元组开始扫描 。
        - 对于  $A < v$ 或 $A \leq v$ 形式的比较条件，无需索引查找。 $A < v$ 时从文件开头扫描到第一个 $A = v$ 的元组前； $A \leq v$ 时类似，扫描到第一个  $A > v$  的元组前 。
    - **A6（辅助索引，比较）**：用辅助有序索引处理涉及  $<$ 、 $\leq$ 、 $\geq$ 、 $>$  的比较条件。扫描最低层索引块， $<$  和  $\leq$  从最小值到  $v$  扫描， $>$  和  $\geq$  从  $v$  到最大值扫描 。辅助索引提供记录指针，但获取实际记录可能需为每个记录进行一次I/O操作（因连续记录可能在不同磁盘块），若检索记录数多，可能比线性搜索更昂贵，所以仅在检索记录少的情况使用 。
- **位图索引扫描（PostgreSQL）**：当辅助索引可用但匹配记录数不确定时，PostgreSQL使用位图索引扫描算法。先创建与关系中块数相同位数的位图并初始化为0 ，通过辅助索引找到匹配元组的索引项，将对应块号的位设置为1 。处理完所有索引项后，扫描位图找到位为1的块（即包含匹配记录的块），然后线性扫描关系，跳过位不为1的块，只获取位为1的块并扫描块内记录。最坏情况比线性扫描略贵，最好情况比线性扫描和辅助索引扫描都便宜很多，保证性能不会比最佳方案差太多 。
- **复杂选择实现**
    - **合取选择**：形式为  $\sigma_{\theta_1 \land \theta_2 \land \cdots \land \theta_n}(r)$  。
    - **析取选择**：形式为  $\sigma_{\theta_1 \lor \theta_2 \lor \cdots \lor \theta_n}(r)$  ，由满足单个简单条件  $\theta_i$  的所有记录的并集满足 。
    - **否定选择**： $\sigma_{\neg \theta}(r)$  的结果是 $r$ 中使条件  $\theta$ 为假的元组集合，无空值时是  $r$  中不在  $\sigma_{\theta}(r)$ 中的元组集合 。
    - **实现算法**：如A7（使用一个索引的合取选择），先确定简单条件中是否有属性存在访问路径，若有则使用相应索引算法，一般比线性搜索快 。
- **索引相关概念**
    - **索引结构**：即访问路径，可定位和访问数据。
    - **聚簇索引**：也叫主索引，能让文件记录按与物理顺序对应的顺序读取 。
    - **辅助索引/非聚簇索引**：非聚簇索引 。
    - **索引扫描**：使用索引的搜索算法，通过选择谓词指导选择处理查询时使用的索引。

### 15.4 排序
- **排序的重要性**：在数据库系统中，数据排序很重要，一是SQL查询可指定输出排序，二是一些关系操作（如连接）在输入关系先排序时能更高效实现。
- **排序方式及问题**：可通过在排序键上建索引并按序读取关系来排序，但这种逻辑排序方式可能导致每条记录都需磁盘访问（寻道 + 块传输），代价高，所以有时需物理排序。
- **外部排序 - 归并算法（External Sort - Merge Algorithm）**
    - **第一阶段（创建排序段）**：设 $M$ 是主存缓冲区可用于排序的块数。重复读取关系的 $M$ 个块（或剩余块），对内存中的部分排序，写入排序文件 $R_i$ ，直到处理完整个关系。
    - **第二阶段（合并排序段）**：若排序段总数 $N$ 小于 $M$ ，为每个段分配一个块并预留一个输出块空间。从每个文件 $R_i$ 读取一个块到内存缓冲区，重复选择所有缓冲区中排序顺序的第一个元组写入输出并删除，若某个段缓冲区为空且文件未结束，则读取下一个块，直到所有输入缓冲区为空。一般情况下，关系大时会产生 $M$ 个或更多排序段，合并需多趟进行，每趟合并 $M - 1$ 个排序段，直到排序段数小于 $M$ ，最后一趟生成排序输出。
- **外部排序 - 归并的成本分析**
    - **磁盘块传输成本**：设 $b_r$ 是包含关系 $r$ 记录的块数，初始阶段读和写块共 $2b_r$ 次传输。初始排序段数为 $\lceil b_r / M\rceil$ 。合并时，为减少寻道，每次读写较多块（设为 $b_b$ ），每趟合并可减少 $\lfloor M / b_b\rfloor - 1$ 个排序段，总合并趟数为 $\lceil\log_{\lfloor M / b_b\rfloor - 1}(b_r / M)\rceil$ 。除最后一趟可能不写回磁盘及部分排序段可能不参与某趟读写外，总块传输数为 $b_r(2\lceil\log_{\lfloor M / b_b\rfloor - 1}(b_r / M)\rceil + 1)$ 。
    - **磁盘寻道成本**：生成排序段及合并过程都需寻道，总寻道数为 $2\lceil b_r / M\rceil + \lceil b_r / b_b\rceil(2\lceil\log_{\lfloor M / b_b\rfloor - 1}(b_r / M)\rceil - 1)$ 。

### 15.5 连接操作
- **等值连接（equi - join）**：指形式为 $r \bowtie_{r.A = s.B} s$ 的连接，其中 $A$ 和 $B$ 分别是关系 $r$ 和 $s$ 的属性或属性集。
- **嵌套循环连接（Nested - Loop Join）**
    - **算法原理**：由一对嵌套的for循环组成，关系 $r$ 为外关系，关系 $s$ 为内关系。用 $t_r \cdot t_s$ 表示连接后的元组。该算法无需索引，适用于任何连接条件，扩展计算自然连接只需在结果中删除重复属性。
    - **成本分析**：需考虑的元组对数量为 $n_r * n_s$ （ $n_r$ 、 $n_s$ 分别是 $r$ 、 $s$ 中的元组数）。最坏情况下，缓冲区只能存每个关系的一个块，需 $n_r * b_s + b_r$ 次块传输（ $b_r$ 、 $b_s$ 分别是 $r$ 、$s$ 的块数）， $n_r + b_r$ 次寻道；最好情况下，两关系都能同时存于内存，只需 $b_r + b_s$ 次块传输和两次寻道。若一个关系能完全存入主存，将其作为内关系可减少传输和寻道次数。

### 选择操作算法补充
- **A8（使用复合索引的合取选择）**：对于某些合取选择，若有合适的复合索引（多个属性上的索引），且选择在两个或更多属性上指定相等条件，可直接搜索索引，根据索引类型确定使用A2、A3或A4算法。
- **A9（通过标识符交集的合取选择）**：涉及使用记录指针或标识符的索引，扫描每个索引获取满足单个条件的元组指针，取指针交集得到满足合取条件的元组指针，再用指针获取实际记录。成本是单个索引扫描成本加上检索指针交集记录的成本，对指针列表排序可降低成本。
- **A10（通过标识符并集的析取选择）**：若析取选择的所有条件都有访问路径，扫描每个索引获取满足单个条件的元组指针，取指针并集得到满足析取条件的元组指针，再用指针获取实际记录。若有一个条件无访问路径，则需对关系进行线性扫描。


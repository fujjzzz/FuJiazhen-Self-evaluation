本周阅读**Database-System-Concepts-7th-Edition**:PART FIVE STORAGE MANAGEMENT AND INDEXING,知识点总结如下：  
**Chapter 14 Indexing**(p623-683)  
>日期：5.20

### 索引（Indexing）基础概念
许多查询仅涉及文件中一小部分记录，为高效定位这些记录，数据库系统引入索引结构。数据库索引类似书籍索引，通过特定结构关联文件，以实现快速定位记录。

### 索引的重要性
在数据库中，索引对于高效处理查询至关重要。若无索引，每个查询都需读取其使用的每个关系的全部内容，对于仅获取少量记录（如单个学生记录）的查询而言，代价过高。

### 索引类型
1. **有序索引（Ordered indices）**：基于值的排序顺序。
    - **聚簇索引（Clustering index）**：若文件中记录按某搜索键顺序存储，且索引的搜索键也定义了文件的顺序，此索引为聚簇索引，也称为主索引（primary index） 。搜索键通常是主键，但并非必须。
    - **非聚簇索引（Nonclustering index/Secondary index）**：搜索键指定的顺序与文件的顺序不同的索引。
2. **哈希索引（Hash indices）**：基于值在一系列桶中的均匀分布。值被分配到哪个桶由哈希函数（hash function）决定。

### 评估索引技术的因素
- **访问类型（Access types）**：能高效支持的访问类型，如查找具有指定属性值的记录，以及查找属性值在指定范围内的记录。
- **访问时间（Access time）**：使用特定技术查找特定数据项或数据项集所需的时间。
- **插入时间（Insertion time）**：插入新数据项所需的时间，包括找到插入新数据项的正确位置的时间，以及更新索引结构的时间。 
- **删除时间（Deletion time）**：删除数据项所需的时间，包括找到要删除的项的时间，以及更新索引结构的时间。 
- **空间开销（Space overhead）**：索引结构占用的额外空间。若额外空间量适中，为提高性能，牺牲空间通常是值得的。

### 有序索引 - 密集索引（Dense index）与稀疏索引（Sparse index）
- **索引项（Index entry/Index record）**：由搜索键值和指向一个或多个具有该搜索键值记录的指针组成。记录指针由磁盘块标识符和磁盘块内的偏移量组成，用于在块内标识记录。
- **密集索引**：文件中的每个搜索键值都有一个索引项。
    - **密集聚簇索引**：索引记录包含搜索键值和指向具有该搜索键值的第一个数据记录的指针。具有相同搜索键值的其余记录将按顺序存储在第一个记录之后。
    - **密集非聚簇索引**：索引必须存储具有相同搜索键值的所有记录的指针列表。 
- **稀疏索引**：仅部分搜索键值有索引项。仅当关系按搜索键的顺序存储（即索引是聚簇索引）时，才能使用稀疏索引。每个索引项包含一个搜索键值和指向具有该搜索键值的第一个数据记录的指针。定位记录时，找到最大的小于或等于要查找的搜索键值的索引项，从该索引项指向的记录开始，按文件中的指针顺序查找，直到找到所需记录。

密集索引定位记录通常比稀疏索引快，但稀疏索引在空间占用和插入、删除操作的维护开销方面更具优势。一种较好的折衷方案是采用每个磁盘块一个索引项的稀疏索引，因为处理数据库请求的主要成本是将磁盘块读入主内存的时间，一旦读入块，扫描整个块的时间可忽略不计，这样能在尽量减小索引大小（即空间开销）的同时，最小化块访问次数。   

### 索引更新（Index Update）
无论使用何种索引形式，当文件中插入或删除记录，或者记录更新影响到索引的搜索键属性时，都需更新索引。记录更新可视为先删除旧记录再插入新记录，从而转化为索引的删除和插入操作。

#### 单级索引更新算法
- **插入（Insertion）**
    - **密集索引（Dense indices）**
        1. 若搜索键值不在索引中，系统在索引的适当位置插入包含该搜索键值的索引项。
        2. 否则：
            - a. 若索引项存储指向具有相同搜索键值的所有记录的指针，系统在索引项中添加指向新记录的指针。
            - b. 若索引项仅存储指向具有搜索键值的第一个记录的指针，系统将插入的记录放在具有相同搜索键值的其他记录之后。
    - **稀疏索引（Sparse indices）**：假设索引为每个磁盘块存储一个索引项。若系统创建新块，按搜索键顺序插入新块中出现的第一个搜索键值到索引中；若新记录在其块中具有最小的搜索键值，系统更新指向该块的索引项；否则，不改变索引。
- **删除（Deletion）**
    - **密集索引（Dense indices）**
        1. 若要删除的记录是其搜索键值对应的唯一记录，系统从索引中删除相应的索引项。
        2. 否则：
            - a. 若索引项存储指向具有相同搜索键值的所有记录的指针，系统从索引项中删除指向被删除记录的指针。
            - b. 若索引项仅存储指向具有搜索键值的第一个记录的指针，且被删除记录是第一个记录，系统更新索引项以指向具有相同搜索键值的下一条记录。
    - **稀疏索引（Sparse indices）**
        1. 若索引不包含要删除记录的搜索键值的索引项，无需对索引进行操作。
        2. 否则：
            - a. 若被删除记录是其搜索键值对应的唯一记录，系统用下一个搜索键值（按搜索键顺序）的索引项替换相应索引记录；若下一个搜索键值已有索引项，则删除该索引项而非替换。
            - b. 若搜索键值的索引项指向被删除记录，系统更新索引项以指向具有相同搜索键值的下一条记录。

### 多级索引（Multilevel Indices）
当索引过大无法全部存储在主内存中时，搜索索引条目需多次磁盘块读取。例如，对占用 $b$ 个块的索引使用二分查找，最多需读取 $\lceil \log_2(b) \rceil$ 个块 （ $\lceil x \rceil$ 表示大于或等于 $x$ 的最小整数）。为解决此问题，构建稀疏的外层索引（outer index）指向原索引（此时称为内层索引，inner index）。定位记录时，先在外层索引上二分查找，找到最大的小于或等于目标搜索键值的记录，其指针指向内层索引的一个块，再扫描该块找到目标记录。

多级索引与树结构密切相关。若文件极大，外层索引也可能过大，可创建更多层级的索引，这种具有两个或更多层级的索引称为多级索引。使用多级索引查找记录比二分查找显著减少I/O操作。

### 二级索引（Secondary Indices）
- 二级索引必须是密集的，为每个搜索键值都有一个索引项，并指向文件中的每个记录。
- 若搜索键不是候选键，二级索引必须包含指向所有具有相同搜索键值记录的指针。
- 对于非唯一搜索键（nonunique search key，即关系中可能有多个记录具有相同搜索键值），实现二级索引的一种方式是索引中的指针不直接指向记录，而是指向桶（bucket），桶中包含指向文件的指针。但此方法有缺点：一是索引访问时间变长，因增加了间接层级，可能需随机I/O操作；二是若键的重复值很少或无重复值，为关联桶分配整个磁盘块会浪费大量空间。 
- 顺序扫描聚簇索引高效，因文件中记录的物理存储顺序与索引顺序相同。但通常无法按聚簇索引和二级索引的搜索键顺序同时物理存储文件，按二级键顺序扫描文件时，读取每个记录可能需从磁盘读取新块，速度很慢。对二级索引也可应用前面描述的插入和删除过程，若文件有多个索引，文件修改时每个索引都需更新。

### B⁺树索引（B⁺-Tree Index）
B⁺树索引是一种多级索引结构，在数据插入和删除操作中仍能保持高效，是应用广泛的索引结构之一。

#### B⁺树结构特点
- **平衡特性**：从根节点到叶节点的每条路径长度相同，“B”代表“balanced”（平衡），此平衡属性确保了查找、插入和删除操作的良好性能。
- **节点结构**
    - **叶节点（Leaf nodes）**：包含最多 $n - 1$ 个搜索键值 $K_1, K_2, \ldots, K_{n - 1}$ 和 $n$ 个指针 $P_1, P_2, \ldots, P_n$ 。搜索键值有序排列，即若 
 $i < j$ ，则 $K_i < K_j$ 。指针 $P_i$（ $i = 1, 2, \ldots, n - 1$ ）指向具有搜索键值 $K_i$ 的文件记录，指针 $P_n$ 用于按搜索键顺序链接叶节点，便于文件的顺序处理。每个叶节点至少包含 $\lceil (n - 1) / 2 \rceil$ 个值。
    - **非叶节点（Nonleaf nodes/Internal nodes）**：结构与叶节点类似，但所有指针都指向树节点。非叶节点最多可容纳 $n$ 个指针，且必须至少持有 $\lceil n / 2 \rceil$ 个指针，节点中指针的数量称为节点的扇出（fanout） 。根节点可以持有少于 $\lceil n / 2 \rceil$ 个指针，但至少要有两个指针（除非树仅由一个节点组成）。对于包含 $m$ 个指针（ $m \leq n$ ）的节点，指针 $P_i$（ $i = 2, 3, \ldots, m - 1$ ）指向包含搜索键值小于 $K_i$ 且大于或等于 $K_{i - 1}$ 的子树；指针 $P_m$ 指向包含大于或等于 $K_{m - 1}$ 的键值的子树部分；指针 $P_1$ 指向包含小于 $K_1$ 的搜索键值的子树部分。

#### B⁺树查询操作
- **查找特定值（find(v)）**：从根节点开始遍历树，寻找包含指定搜索键值 $v$ 的叶节点。具体步骤为，以当前节点（初始为根节点）为基础，查找最小的 $i$ 使得搜索键值 $K_i$ 大于或等于 $v$ 。若找到且 $K_i = v$ ，则将当前节点设为 $P_{i + 1}$ 指向的节点；若 $K_i > v$ ，则将当前节点设为 $P_i$ 指向的节点。若未找到，则当 $v > K_{m - 1}$ （ $P_m$ 是节点中最后一个非空指针）时，将当前节点设为 $P_m$ 指向的节点。重复此过程，直到到达叶节点。在叶节点中，若存在搜索键值 $K_i = v$ ，则返回指向该记录的指针 $P_i$ ；否则返回空指针，表示不存在具有键值 $v$ 的记录。伪代码如下：
```
function find(v)
/* Assumes no duplicate keys, and returns pointer to the record with
* search key value v if such a record exists, and null otherwise */
    Set C = root node
    while (C is not a leaf node) begin
        Let i = smallest number such that v ≤ C.Ki
        if there is no such number i then begin
            Let Pm = last non-null pointer in the node
            Set C = C.Pm
        end
        else if (v = C.Ki) then Set C = C.Pi+1
        else Set C = C.Pi /* v < C.Ki */
    end
    /* C is a leaf node */
    if for some i, Ki = v
        then return Pi
        else return null ; /* No record with key value v exists*/
```
- **范围查询（findRange(lb, ub)）**：用于查找搜索键值在指定范围 $[lb, ub]$ 内的所有记录。先以类似于 `find(lb)` 的方式遍历到一个叶节点（该叶节点可能包含也可能不包含值 $lb$ ），然后遍历该叶节点及后续叶节点中的记录，将键值满足 $lb \leq C.K_i \leq ub$ 的记录指针收集到结果集中，当 $C.K_i > ub$ 或树中没有更多键值时停止。实际实现中会提供类似JDBC ResultSet的迭代器接口，通过 `next()` 方法按顺序获取记录。

#### 处理非唯一搜索键
一般情况下，搜索键可能存在重复值。处理方式包括：
- 修改树结构，在叶节点中为每个出现的搜索键存储多个副本，每个副本指向一个记录，但这会使插入和删除过程更复杂且成本更高，还可能导致内部节点出现重复搜索键值。
- 为每个搜索键值存储一组记录指针，但当特定键的记录指针数量很大时，可能导致访问效率低下。
- 大多数数据库通过创建唯一的复合搜索键来处理，例如关系 $r$ 中期望的搜索键属性 $a_i$ 非唯一，设 $A_p$ 为 $r$ 的主键，则构建索引时使用唯一的复合搜索键 $(a_i, A_p)$ 替代 $a_i$ 。

### 多键索引（Indices on Multiple Keys）
搜索键可以包含多个属性，这种搜索键称为复合搜索键（composite search key），其索引结构与单属性搜索键索引相同，只是搜索键是属性列表，可表示为元组 $(a_1, \ldots, a_n)$ 形式，其中 $A_1, \ldots, A_n$ 为索引属性。复合搜索键值按字典序（lexicographic ordering）排序，例如对于两个属性的搜索键 $(a_1, a_2)$ 和 $(b_1, b_2)$  ，若 $a_1 < b_1$ 或 $a_1 = b_1$ 且 $a_2 < b_2$ ，则 $(a_1, a_2) < (b_1, b_2)$ 。如在 `takes` 关系上基于复合搜索键 `(course_id, semester, year)` 创建的索引，可用于高效查找在特定学期/年份注册特定课程的所有学生，也能有效回答其他相关类型的查询。  

### B⁺树的插入操作
在B⁺树中插入记录时，需更新相应索引，插入操作比查找更复杂，可能需对节点进行分裂（split）以处理插入后节点过大的情况。

#### 插入流程
1. **查找插入位置**：使用与 `find()` 函数（用于查找特定值）相同的技术，找到搜索键值应插入的叶节点。
2. **插入索引项**：在找到的叶节点中插入一个条目（即搜索键值和记录指针对），并确保搜索键仍有序。
3. **处理节点溢出**：若插入后叶节点已满（有 $n - 1$ 个键值），则需分裂节点。
    - **叶节点分裂**：将叶节点中的 $n$ 个搜索键值（包括要插入的值）分成两部分，前 $\lceil n / 2 \rceil$ 个值留在原节点，其余值放入新创建的节点。新节点的最小搜索键值需插入到其父节点中。若父节点有空间容纳新条目，则插入完成；若父节点无空间，则父节点也需分裂，此过程可能一直向上影响到根节点，极端情况下会导致树的深度增加。
    - **非叶节点分裂**：与叶节点分裂略有不同。当非叶节点溢出时，先临时扩展父节点以添加新条目，然后立即分裂。子节点指针在原节点和新节点间分配，原节点保留前几个指针，新节点获得其余指针。位于移到右节点指针之间的搜索键值随指针移动，位于左节点指针之间的搜索键值保持不变。而位于左右指针之间的搜索键值不添加到分裂后的节点，而是作为一个条目添加到父节点（其指针指向新创建的节点）。

插入操作伪代码如下：
```
procedure insert(value K, pointer P)
    if (tree is empty) create an empty leaf node L, which is also the root
    else Find the leaf node L that should contain key value K
    if (L has less than n - 1 key values)
        then insert_in_leaf (L,K,P)
    else begin /* L has n - 1 key values already, split it */
        Create node L'
        Copy L.P1... L.Kn-1 to a block of memory T that can
            hold n (pointer, key-value) pairs
        insert_in_leaf (T,K,P)
        Set L'.Pn = L.Pn; Set L.Pn = L'
        Erase L.P1 through L.Kn-1 from L
        Copy T.P1 through T.K⌈n/2⌉ from T into L starting at L.P1
        Copy T.P⌈n/2⌉+1 through T.Kn from T into L' starting at L'.P1
        Let K' be the smallest key-value in L'
        insert_in_parent(L, K', L')
    end
```

### B⁺树的删除操作
从关系中删除记录时，同样需更新B⁺树索引，删除操作也可能涉及节点合并（coalesce）以处理节点过小（指针数少于 $\lceil n / 2 \rceil$ ）的情况。

#### 删除流程
1. **查找删除位置**：使用与查找相同的技术，通过对要删除记录的搜索键值进行查找，找到包含该条目的叶节点。若有多个具有相同搜索键值的条目，则遍历所有相同搜索键值的条目，直到找到指向要删除记录的条目。
2. **删除索引项**：从叶节点中移除该条目，同时将叶节点中位于被删除条目右侧的所有条目向左移动一个位置，以消除条目中的间隙。
3. **处理节点合并**：若删除后节点中的指针数少于 $\lceil n / 2 \rceil$ ，则可能需要与相邻节点合并，或从相邻节点借调一些条目来填充节点，以保持树的平衡属性。

### B⁺树查询的成本分析
- **单值查询成本**：处理查询时，从根节点到叶节点遍历树的路径长度不超过 $\lceil \log_{\lceil n/2 \rceil}(N) \rceil$ ，其中  $N$  是文件中的记录数。通常节点大小设为与磁盘块大小相同（一般为4KB ），以搜索键大小12字节、磁盘指针大小8字节估算， $n$  约为200；保守估计搜索键大小为32字节时， $n$  约为100 。当  $n = 100$  ，文件中有100万个搜索键值时，查找最多需访问  $\lceil \log_{50}(1,000,000) \rceil = 4$  个节点，即最多从磁盘读取4个块。根节点常被频繁访问，可能已在缓冲区中，所以通常只需从磁盘读取3个或更少的块。遍历到叶节点层后，对于唯一搜索键的单值查询，还需一次随机I/O操作来获取匹配记录。 
- **范围查询成本**：范围查询在遍历到叶节点层后，需检索给定范围内的所有指针。这些指针在连续的叶节点中，若检索到  $M$  个指针，最多需访问  $\lceil M / (n / 2) \rceil + 1$  个叶节点来检索指针（因为每个叶节点至少有 $n / 2$ 个指针） 。此外，还需加上访问实际记录的成本。对于二级索引，每条记录可能在不同块上，最坏情况下可能导致  $M$  次随机I/O操作；对于聚簇索引，这些记录在连续块中，成本显著降低。

### B⁺树更新操作的复杂性
B⁺树的插入和删除操作虽复杂，但I/O操作相对较少，这是重要优势，因为I/O操作成本较高。

#### 插入操作复杂性
在最坏情况下，插入操作所需的I/O操作数量与 $\log_{\lceil n/2 \rceil}(N)$ 成正比 ，其中 $n$ 是节点中指针的最大数量，$N$ 是被索引文件中的记录数。具体插入流程如下：
1. **查找插入位置**：通过类似查找的方法找到应插入搜索键值的叶节点。
2. **插入索引项**：在叶节点中插入搜索键值和记录指针对，并保证搜索键有序。
3. **处理节点溢出**：若叶节点已满（有 $n - 1$ 个键值），则分裂节点。
    - **叶节点分裂**：将 $n$ 个搜索键值（含要插入的值）分成两部分，前 $\lceil n / 2 \rceil$ 个留在原节点，其余放入新节点。新节点最小搜索键值插入父节点，若父节点无空间则继续分裂，可能影响到根节点。
    - **非叶节点分裂**：临时扩展父节点添加新条目后分裂。子节点指针在原节点和新节点分配，原节点留前几个指针，新节点获其余指针。部分搜索键值随指针移动，部分保留，位于左右指针间的搜索键值添加到父节点（指向新节点）。

插入操作相关伪代码：
```
procedure insert(value K, pointer P)
    if (tree is empty) create an empty leaf node L, which is also the root
    else Find the leaf node L that should contain key value K
    if (L has less than n - 1 key values)
        then insert_in_leaf (L,K,P)
    else begin /* L has n - 1 key values already, split it */
        Create node L'
        Copy L.P1... L.Kn-1 to a block of memory T that can
            hold n (pointer, key-value) pairs
        insert_in_leaf (T,K,P)
        Set L'.Pn = L.Pn; Set L.Pn = L'
        Erase L.P1 through L.Kn-1 from L
        Copy T.P1 through T.K⌈n/2⌉ from T into L starting at L.P1
        Copy T.P⌈n/2⌉+1 through T.Kn from T into L' starting at L'.P1
        Let K' be the smallest key-value in L'
        insert_in_parent(L, K', L')
    end

procedure insert_in_leaf (node L, value K, pointer P)
    if (K < L.K1)
        then insert P,K into L just before L.P1
    else begin
        Let Ki be the highest value in L that is less than or equal to K
        Insert P,K into L just after L.Ki
    end

procedure insert_in_parent(node N, value K', node N')
    if (N is the root of the tree)
        then begin
            Create a new node R containing N,K',N'  /* N and N' are pointers */
            Make R the root of the tree
            return
        end
    Let P = parent (N)
    if (P has less than n pointers)
        then insert (K',N') in P just after N
    else begin /* Split P */
        Copy P to a block of memory T that can hold P and (K',N')
        Insert (K',N') into T just after N
        Erase all entries from P; Create node P'
        Copy T.P1... T.P⌈(n+1)/2⌉ into P
        Let K'' = T.K⌈(n+1)/2⌉
        Copy T.P⌈(n+1)/2⌉+1... T.Pn+1 into P'
        insert_in_parent(P, K'', P')
    end
```

#### 删除操作复杂性
在搜索键无重复值的情况下，删除操作的最坏情况复杂性也与 $\log_{\lceil n/2 \rceil}(N)$ 成正比 。删除流程如下：
1. **查找删除位置**：通过查找找到包含要删除记录条目的叶节点。
2. **删除索引项**：从叶节点移除条目，将右侧条目左移。
3. **处理节点合并**：若删除后节点指针数少于 $\lceil n / 2 \rceil$ （非叶节点）或 $\lceil (n - 1) / 2 \rceil$ （叶节点） ，则进行节点合并或从相邻节点借调条目。
    - **节点合并**：当节点指针数过少，若与相邻节点条目能合并到一个节点，则合并节点，同时删除父节点指向被删除节点的条目。
    - **条目借调（Redistribution）**：若不能合并，则从相邻节点借调一个条目，调整相关指针和键值，同时更新父节点中分隔键值。

删除操作伪代码：
```
procedure delete(value K, pointer P)
    find the leaf node L that contains (K,P)
    delete_entry(L, K, P)

procedure delete_entry(node N, value K, pointer P)
    delete (K,P) from N
    if (N is the root and N has only one remaining child)
        then make the child of N the new root of the tree and delete N
    else if (N has too few values/pointers) then begin
        Let N' be the previous or next child of parent(N)
        Let K' be the value between pointers N and N' in parent(N)
        if (entries in N and N' can fit in a single node)
            then begin /* Coalesce nodes */
                if (N is a predecessor of N') then swap_variables(N,N')
                if (N is not a leaf)
                    then append K' and all pointers and values in N to N'
                    else  append all (Ki,Pi) pairs in N to N'; set N'.Pn = N.Pn
                delete_entry(parent(N), K', N); delete node N
            end
        else begin /* Redistribution: borrow an entry from N' */
            if (N' is a predecessor of N) then begin
                if (N is a nonleaf node) then begin
                    let m be such that N'.Pm is the last pointer in N'
                    remove (N'.Km-1, N'.Pm) from N'
                    insert (N'.Pm,K') as the first pointer and value in N,
                        by shifting other pointers and values right
                    replace K' in parent(N) by N'.Km-1
                end
                else begin
                    let m be such that (N'.Pm, N'.Km) is the last pointer/value
                        pair in N'
                    remove (N'.Pm, N'.Km) from N'
                    insert (N'.Pm, N'.Km) as the first pointer and value in N,
                        by shifting other pointers and values right
                    replace K' in parent(N) by N'.Km
                end
            end
            else  ... symmetric to the then case ...
        end
    end
```

### 实际操作中的性能表现
实际中，B⁺树操作的I/O操作比最坏情况少。节点扇出为100且叶节点访问均匀分布时，叶节点父节点被访问概率是叶节点的100倍，非叶节点数量远少于叶节点。如今内存大，常用B⁺树的非叶节点多在数据库缓冲区，查找通常只需一两次I/O操作。插入时节点分裂概率小，平均每次插入写更新块的I/O操作略多于一次 。随机插入时节点平均超过三分之二满，有序插入时节点仅半满。  

### B⁺树的扩展与相关问题处理
#### B⁺树文件组织（B⁺-Tree File Organization）
 - **解决性能退化问题**：索引顺序文件组织随文件增长性能会下降，表现为索引条目和实际记录无序并存储在溢出块中。使用B⁺树索引可解决索引查找性能退化问题，利用B⁺树的叶层组织包含实际记录的块，将B⁺树结构既作为索引又作为文件中记录的组织者。在B⁺树文件组织中，叶节点存储记录而非记录指针。
 - **插入和删除操作**：插入记录时，系统通过在B⁺树中查找最大的小于等于插入键值  $v$  的键来定位应包含记录的块，若块有足够空间则存储记录，否则像B⁺树插入那样分裂块并重新分配记录，分裂会按正常方式向上传播。删除记录时，先从包含它的块中移除，若块因删除变得少于半满，则与相邻块重新分配记录，系统按常规方式更新B⁺树的非叶节点。
 - **空间利用率优化**：插入时，若节点已满，尝试将部分条目重新分配到相邻节点以腾出空间，若相邻节点也满则分裂节点，并在三个节点（原节点、分裂出的新节点、一个相邻节点）间平均分配条目。删除时，若节点占用率低于  $\lfloor 2n/3 \rfloor$ （ $n$  是节点可容纳的最大条目数 ），尝试从相邻节点借调条目；若相邻节点都有  $\lfloor 2n/3 \rfloor$  条记录，则在三个相邻节点间重新分配条目并删除其中一个节点。一般来说，若  $m$  个节点（ $m - 1$  个相邻节点 ）参与重新分配，每个节点可保证至少有 
 $\lfloor (m - 1)n/m \rfloor$  条记录 ，但参与重新分配的相邻节点越多，更新成本越高。

#### 辅助索引与记录重定位（Secondary Indices and Record Relocation）
 - **问题**：在B⁺树文件组织中，叶节点分裂等情况会导致记录位置改变，存储指向这些记录指针的辅助索引需更新，由于每个叶节点可能包含大量记录且在不同辅助索引中位置不同，更新所有受影响的辅助索引可能需大量I/O操作，成本高昂。
 - **解决方案**：在辅助索引中存储主索引搜索键属性的值，而非记录指针。例如在 `instructor` 关系的 `ID` 属性上有主索引，在 `dept_name` 上的辅助索引存储对应记录的 `ID` 值列表。记录因叶节点分裂重定位时无需更新此类辅助索引，但使用辅助索引定位记录需两步：先通过辅助索引找到主索引搜索键值，再用主索引找到对应记录。此方法虽增加了使用辅助索引访问数据的成本，但大大降低了因文件重组导致的索引更新成本。

#### 字符串索引（Indexing Strings）
 - **问题**：在字符串值属性上创建B⁺树索引存在两个问题，一是字符串长度可变，二是字符串可能很长，导致节点扇出低、树高增加。长度可变的搜索键会使不同节点即使满也可能有不同扇出，节点满（无空间添加新条目）时需分裂，合并或重新分配条目依据节点空间使用比例而非可容纳的最大条目数。
 - **解决方法**：使用前缀压缩（prefix compression）技术增加节点扇出，在非叶节点不存储完整搜索键值，仅存储足以区分其分隔子树键值的前缀。例如在名字索引中，非叶节点存储 `Silb` 而非完整的 `Silberschatz` 来区分 `Silas` 和 `Silver` 所在子树。

#### B⁺树索引批量加载（Bulk Loading of B⁺-Tree Indices）
构建B⁺树索引插入记录时，最坏情况下I/O操作数量与树高成正比，通常树高较小（即使对大型关系，一般为5或更小 ）。但在大型关系上构建B⁺树且索引大于主存时，扫描关系并添加条目到B⁺树，访问的叶节点很可能不在数据库缓冲区，每次向叶节点添加条目都可能需磁盘寻道获取包含叶节点的块，且在再次添加条目到该块前可能被逐出缓冲区，导致再次磁盘寻道写回块。  
>日期：5.22  

#### 非唯一搜索键（Nonunique Search Keys）
 - **使搜索键唯一的方法**：此前假设搜索键唯一，可通过创建包含原始搜索键和额外属性（如记录id、主键等唯一属性，称为唯一化属性）的复合搜索键来实现唯一性。
 - **处理非唯一搜索键的方式**
    - **存储键值一次并维护记录指针桶**：在树中每个键值只存储一次，维护一个记录指针桶（或列表）处理非唯一搜索键。此方法节省空间，但实现B⁺树时会产生复杂情况，如在叶节点存储桶需处理可变大小桶及桶超出叶节点大小的情况；若桶存储在单独块中，可能需额外I/O操作获取记录。
    - **每条记录存储一次搜索键值**：每条记录存储一次搜索键值，插入时叶节点满可按常规方式分裂，但处理分裂和内部节点搜索更复杂，因可能有两个叶节点包含相同搜索键值，且空间开销更高，因为键值存储次数与包含该值的记录数相同。
 - **非唯一搜索键删除效率问题**：与唯一搜索键方法相比，上述两种处理非唯一搜索键的方法在记录删除效率上存在问题。当某搜索键值出现次数多，删除对应记录时可能需遍历多个叶节点中相同搜索键值的条目，最坏情况删除复杂性可能与记录数成线性关系。而使用唯一搜索键方法删除记录时，计算复合搜索键值后从根到叶单次遍历即可找到对应叶层条目，最坏情况删除成本与记录数成对数关系。因此，多数数据库系统的B⁺树实现只处理唯一搜索键，自动添加记录id或其他属性使非唯一搜索键唯一。

### B⁺树在不同存储介质上的应用及相关索引结构
#### B⁺树在闪存存储（Flash Storage）上的应用
 - **性能优势与结构适配**：标准B⁺树索引在固态硬盘（SSD）上仍可使用，相比磁盘存储，更新性能可接受且查找性能显著提升。闪存存储以页为结构，B⁺树索引结构可与之配合。SSD的随机I/O操作比磁盘快得多，随机页读取只需约20 - 100微秒，而磁盘约需5 - 10毫秒，因此在SSD上数据查找更快。
 - **写操作特性与优化**：闪存存储的写操作性能更复杂，其物理层面不允许原地更新，每次更新都变为对整个闪存页的复制 + 写入，之后需擦除旧页，新页写入需20 - 100微秒，旧页擦除在块级别进行，一个块擦除需2 - 5毫秒 。闪存存储的最佳B⁺树节点大小比磁盘小，因为闪存页比磁盘块小，节点大小与闪存页匹配可减少更新时的多页写入。尽管小页会使树变高、增加I/O操作，但闪存的随机页读取速度快，总体读性能影响小。批量加载在SSD上仍比逐元组插入有显著性能优势，自底向上构建B⁺树可减少页写入次数。
 - **减少擦除操作的扩展方法**：为减少因页重写导致的擦除操作，提出了几种B⁺树扩展方法。一种是在B⁺树内部节点添加缓冲区，将更新暂时记录在高层缓冲区，延迟推送到下层，关键是将多个更新一起应用，减少每次更新的页写入数；另一种是创建多棵树并合并，如日志结构合并树及其变体。

#### B⁺树在主内存（Main Memory）中的应用
 - **结构适用与优化方向**：主内存如今容量大且成本低，许多组织可将操作数据全部存入内存，B⁺树可用于索引内存数据且结构无需改变，但可进行一些优化。
 - **空间与结构优化**：内存比磁盘空间成本高，主内存数据库的内部数据结构需设计为减少空间需求，可使用提高B⁺树存储利用率的技术来降低内存中B⁺树的内存使用。与基于磁盘的数据不同，内存数据可接受需要遍历多个指针的数据结构，因此主内存数据库中的树结构可以相对较深。
 - **缓存与性能优化**：缓存内存和主内存的速度差异以及数据以缓存行（通常约64字节）为单位在主内存和缓存间传输，使得缓存和主内存的关系与主内存和磁盘的关系有相似性（尽管速度差异较小）。读取内存位置时，缓存命中CPU可在1 - 2纳秒完成读取，缓存未命中则从主内存读取数据会延迟约50 - 100纳秒 。适合缓存行大小的小节点B⁺树在内存数据上表现良好，相比高瘦的树结构（如二叉树），其索引操作缓存未命中更少。对于数据不完全在内存但常用数据常驻内存的数据库，使用大节点优化磁盘访问，同时将节点内数据结构设计为树，使子节点大小与缓存行匹配，通过节点内的树结构访问数据可减少缓存未命中次数。

#### 哈希索引（Hash Indices）
哈希是在主内存中构建索引的常用技术，此类索引可临时创建用于处理连接操作，也可能是主内存数据库中的永久结构，哈希也用于组织文件中的记录，但哈希文件组织应用不广泛，先考虑内存哈希索引，之后讨论基于磁盘的哈希。

#### B⁺树索引的批量加载（Bulk Loading of B⁺-Tree Indices）
 - **传统插入的低效性**：向B⁺树插入大量条目时，若按常规逐元组插入，每次插入可能需随机读和随机写操作。例如关系有1亿条记录，磁盘I/O操作每次约10毫秒，仅读取叶节点构建索引就至少需100万秒，时间成本高。
 - **批量加载方法**：高效的批量加载方法是先创建包含关系索引条目的临时文件，按构建索引的搜索键排序，最后扫描排序文件并插入索引。有高效算法对大关系排序，假设内存合理，I/O成本与多次读取文件相当。在将条目插入B⁺树前进行排序有显著好处，排序后插入，特定叶节点的条目连续出现，叶节点只需写入一次，节点无需从磁盘加载，即使插入多个条目每个叶节点也仅需一次I/O操作。若每个叶节点含100个条目，叶层有100万个节点，创建叶层仅需100万次I/O操作，若连续叶节点分配在连续磁盘块上，这些I/O操作可能是顺序的，磁盘寻道少。
 - **自底向上构建B⁺树**：若B⁺树初始为空，自底向上从叶层构建比常规插入更快。在自底向上构建中，先对条目排序，将排序后的条目分成块，块中的条目数尽量填满块，这些块构成B⁺树的叶层，每个块的最小值和指向块的指针用于创建B⁺树的下一层条目，依此构建直到创建根节点。多数数据库系统在创建关系索引时，基于条目的排序和自底向上构建实现高效技术，对已有索引的关系逐元组添加元组时使用常规插入过程，部分数据库系统建议若一次向已有关系添加大量元组，应先删除关系上的索引（主键索引除外），插入元组后再重新创建索引，以利用高效的批量加载技术。

#### B树索引文件（B-Tree Index Files）
 - **与B⁺树索引的区别**：B树索引与B⁺树索引相似，主要区别在于B树消除了搜索键值的冗余存储。在B⁺树中搜索键值在非叶节点和叶节点都可能出现，而B树中搜索键值（若唯一）只出现一次。B树非叶节点需为每个搜索键包含额外指针字段，指向文件记录或相关搜索键的桶。
 - **查找与操作特性**：B树查找时访问节点数取决于搜索键位置，有时在到达叶节点前就能找到所需值，但B树叶层存储的键数约为非叶层的 $n$ 倍（$n$ 通常较大） ，提前找到某些值的优势相对较小，且B树非叶节点搜索键少，扇出小，深度可能比对应B⁺树大，一般来说查找时间仍与搜索键数量的对数成正比。B树删除更复杂，被删除条目可能在非叶节点，需从包含被删除条目的节点子树中选择合适值替换，若叶节点条目过少还需进一步处理；B树插入仅比B⁺树插入稍复杂。
 - **应用情况**：对于大型索引，B树的空间优势不明显，通常无法抵消其缺点，因此几乎所有数据库系统实现都使用B⁺树数据结构，尽管很多时候将其称为B树。

### 多键访问、覆盖索引及索引创建相关知识
#### 多键访问（Multiple - Key Access）
 - **使用多个单键索引（Using Multiple Single - Key Indices）**：以 `instructor` 文件有 `dept_name` 和 `salary` 两个索引为例，对于查询“找出金融系工资为80000美元的所有教师”（`select ID from instructor where dept_name = 'Finance' and salary = 80000;` ），有三种处理策略。一是用 `dept_name` 索引找到金融系记录，再检查工资是否为80000；二是用 `salary` 索引找到工资为80000的记录，再检查部门是否为金融系；三是分别用两个索引找到对应记录指针，取交集，第三种策略利用了多个索引，但在某些情况下（金融系记录多、工资80000记录多、两者都符合的记录少 ）可能不佳，位图索引可在一定程度上加速第三种策略的交集操作。
 - **多键索引（Indices on Multiple Keys）**：创建复合搜索键（如 `(dept_name, salary)` ）的有序（B⁺树）索引，可高效处理如 `select ID from instructor where dept_name = 'Finance' and salary = 80000;` 、`select ID from instructor where dept_name = 'Finance' and salary < 80000;` 以及 `select ID from instructor where dept_name = 'Finance';` 等查询，因为等值条件可等效为范围查询。但对于如 `select ID from instructor where dept_name < 'Finance' and salary < 80000;` 这类查询，使用该索引可能导致磁盘块的随机I/O操作，因为第一个属性是比较条件而非等值条件，不对应范围查询。为加速一般复合搜索键查询，可使用位图索引、R - 树等特殊结构，R - 树是B⁺树扩展用于处理多维索引。

#### 覆盖索引（Covering Indices）
覆盖索引是除存储记录指针外，还存储某些非搜索键属性值的索引。在 `instructor` 关系的 `ID` 属性非聚集索引中存储 `salary` 属性值，可在不访问实际记录的情况下处理只涉及 `salary` （不涉及其他属性如 `dept_name` ）的查询。创建 `(ID, salary)` 索引也有类似效果，但覆盖索引可减小搜索键大小，增加非叶节点扇出，潜在降低索引高度。

#### 索引创建（Creation of Indices）
 - **SQL语法**：SQL标准未指定创建索引的特定语法，但多数数据库支持创建和删除索引的SQL命令。创建索引语法为 `create index <index - name> on <relation - name> (<attribute - list>);` ，`attribute - list` 是构成索引搜索键的关系属性列表；删除索引语法为 `drop index <index - name>;` 。例如创建名为 `dept_index` 、以 `dept_name` 为搜索键的 `instructor` 关系索引，语句为 `create index dept_index on instructor (dept_name);` 。用 `create unique index` 声明属性或属性列表为候选键，支持多种索引类型的数据库还可在创建命令中指定索引类型。当用户提交可利用索引的SQL查询时，SQL查询处理器自动使用索引。

### 哈希索引相关知识
#### 哈希索引基本概念（Hash Indices Basics）
 - **术语定义**：哈希中用“桶（bucket）”表示可存储一个或多个记录的存储单元，内存哈希索引中桶可是索引条目或记录的链表，磁盘索引中桶是磁盘块链表。哈希函数（hash function）$h$ 是从搜索键值集合 $K$ 到桶地址集合 $B$ 的函数，内存哈希索引中桶集合是指针数组，第 $i$ 个桶在偏移量 $i$ 处，指针存储桶内链表头部。
 - **插入操作**：插入搜索键为 $K_i$ 的记录时，计算 $h(K_i)$ 得到记录桶地址，将记录索引条目添加到对应偏移量链表。处理桶中多条记录情况的常见哈希索引变体是溢出链（overflow chaining），也叫闭地址法（closed addressing 或 closed hashing） 。
 - **查找操作**：查找搜索键值 $K_i$ 时，计算 $h(K_i)$ ，然后搜索对应地址桶。若两个搜索键 $K_5$ 和 $K_7$ 哈希值相同，查找 $K_5$ 时需检查桶内所有记录搜索键值。
 - **范围查询限制**：与B⁺树索引不同，哈希索引不支持范围查询，如无法高效处理检索所有满足 $l \leq v \leq u$ 的搜索键值 $v$ 的查询。
 - **删除操作**：删除搜索键值为 $K_i$ 的记录时，计算 $h(K_i)$ ，搜索对应桶并删除记录，链表表示下删除操作简单。

#### 磁盘哈希索引及桶溢出处理（Disk - Based Hash Indices and Bucket Overflow）
 - **插入与桶溢出**：磁盘哈希索引插入记录时，先通过搜索键哈希定位桶，若桶有空间则存储记录，否则发生桶溢出（bucket overflow） ，通过溢出桶（overflow buckets）处理，若桶 $b$ 满，系统为其提供溢出桶插入记录，溢出桶满再提供新溢出桶，所有溢出桶链表相连。查找时需搜索主桶及其溢出桶。
 - **桶溢出原因及处理**：桶溢出可能因记录数多而桶数量不足，或记录分布不均（偏斜，skew ），如多个记录有相同搜索键或哈希函数导致搜索键分布不均匀。为降低桶溢出概率，桶数量选为 $(n_r/f_r) * (1 + d)$ ，$n_r$ 是记录数，$f_r$ 是每个桶记录数，$d$ 是调节因子（通常约0.2 ），会使桶空间约20% 空闲，但可减少溢出概率。

#### 静态与动态哈希（Static and Dynamic Hashing）
 - **静态哈希（Static Hashing）**：创建索引时桶数量固定的哈希索引叫静态哈希，问题是需提前知道存储记录数，若记录数远超桶数，查找需搜索大量记录，效率降低。
 - **动态哈希（Dynamic Hashing）**：处理记录数增加问题可重建哈希索引增加桶数，如记录数是桶数两倍时，重建索引使桶数翻倍，但重建耗时可能长影响正常处理。动态哈希技术（如线性哈希和可扩展哈希 ）可更渐进增加桶数，详见24.5节。

### 写优化索引结构
#### LSM树（LSM Trees）
 - **结构组成**：LSM树由多个B⁺树组成，起始于内存树 $L_0$ ，以及磁盘树 $L_1, L_2, \ldots, L_k$ （$k$ 为层数 ）。
 - **插入与查找**：记录先插入内存B⁺树结构 $L_0$ ，$L_0$ 空间被填满后，若 $L_1$ 为空，将 $L_0$ 整体写入磁盘创建初始 $L_1$ ；若 $L_1$ 不为空，按键值升序扫描 $L_0$ 和 $L_1$ 的叶层并合并条目，用自底向上构建过程创建新B⁺树替换旧 $L_1$ ，之后删除 $L_0$ 和旧 $L_1$ 条目，可继续向空的 $L_0$ 插入。索引查找通过在各树 $L_0, \ldots, L_k$ 上分别进行查找操作并合并结果。
 - **删除与更新**：删除操作通过插入删除条目指示要删除的索引条目，插入删除条目的过程与插入普通索引条目相同。查找时需多一步，若存在某条目的删除条目，查找会同时找到删除条目和原条目，过滤掉要删除的条目。树合并时，若一棵树有条目，另一棵树有匹配的删除条目，两者在合并时匹配并丢弃。更新操作与删除类似，通过插入更新条目处理，查找需匹配更新条目和原条目并返回最新值，实际更新在合并时进行，当一棵树有条目，另一棵树有匹配更新条目时，合并过程应用更新并丢弃更新条目。
 - **变体与应用**：LSM树变体如阶梯合并索引（stepped-merge index） ，每层可有多个树，可显著降低插入成本，但可能增加查询成本，通过布隆过滤器（Bloom filters）减少查找次数。LSM树最初用于降低磁盘写和寻道开销，在闪存存储中，虽避免随机I/O的优势不明显，但因闪存不能原地更新，相比传统B⁺树，LSM树变体减少写操作次数可带来性能优势。Google的BigTable系统、Apache HBase以及许多大数据存储系统（如Apache Cassandra、Apache AsterixDB、MongoDB ）、MySQL（使用MyRocks存储引擎）、嵌入式数据库系统SQLite4和LevelDB都支持LSM树。

#### 缓冲树（Buffer Tree）
 - **原理**：缓冲树是日志结构合并树方法的替代方案，其核心是为B⁺树的每个内部节点（包括根节点）关联一个缓冲区。
 - **插入操作**：索引记录插入缓冲树时，先插入根节点缓冲区，缓冲区满时，将其中索引记录按搜索键排序推到合适子节点缓冲区，若子节点是内部节点且缓冲区满，重复上述过程，若子节点是叶节点则按常规方式插入，若插入导致叶节点溢出，按常规B⁺树方式分裂，内部节点溢出分裂时也分裂缓冲区并按键值划分缓冲区条目。
 - **查找操作**：查找按常规B⁺树方式遍历找到匹配键值的叶节点，额外步骤是检查遍历的每个内部节点缓冲区是否有匹配查找键的记录，范围查找类似常规B⁺树，但需检查叶节点上方所有内部节点缓冲区。假设内部节点缓冲区记录数是子节点数的 $k$ 倍，平均每次向每个子节点推 $k$ 条记录，记录在推之前排序以确保连续推送。插入时缓冲树方法可分摊访问子节点和写回更新节点的成本，$k$ 足够大时节省显著。
 - **删除与更新**：删除和更新处理与LSM树类似，可使用删除条目或更新条目，也可用常规B⁺树算法，但可能I/O成本更高。缓冲树在I/O操作数量的最坏情况复杂度边界优于LSM树变体，读取成本比LSM树快，但写操作涉及随机I/O。

#### 索引的作用与创建策略
 - **索引的作用**：索引对参与查询选择条件或连接条件的属性很有用，可显著降低查询成本。如查询特定学生ID（`σ_ID=12345(takes)` ）的 `takes` 记录，若 `takes` 的 `ID` 属性有索引，只需少量I/O操作获取记录指针，若无索引则需读取整个关系。
 - **索引的成本**：索引有成本，底层关系更新时索引需更新，创建过多索引会减慢更新处理，因为每次更新需更新所有受影响索引。
 - **索引创建策略**：构建应用时需确定重要索引，关系声明主键后多数数据库系统自动在主键创建索引，插入元组时可用于检查主键约束。虽多数数据库系统不自动在外部键属性创建索引，但创建外键索引常是好选择，多数连接在外键和主键属性间，含此类连接且在引用表有选择条件的查询常见。许多数据库系统提供工具帮助管理员跟踪查询和更新并推荐创建索引，一些云数据库系统支持自动创建索引以避免重复关系扫描。

### 空间和时间数据索引相关结构
#### k - d树（k - d Tree）
 - **结构原理**：k - d树是早期用于多维索引的树结构，其每层将空间划分为两部分，在树的顶层节点沿一个维度划分，下一层节点沿另一个维度划分，循环遍历各维度，划分方式使得每个节点的子树中大约一半的点落在一侧，另一半落在另一侧，当节点中的点数少于给定的最大数量时，划分停止。
 - **范围查询**：矩形范围查询（指定矩形区域内的点）可通过递归过程高效执行。从根节点开始，若节点是内部节点，在特定维度（如 $x$ 维度）的某点 $x_i$ 进行划分，左子树中的条目 $x$ 值小于 $x_i$ ，右子树中的条目 $x$ 值大于等于 $x_i$ 。若查询范围包含 $x_i$ ，则在两个子节点上递归搜索；若查询范围在 $x_i$ 左侧，则仅在左子节点递归搜索；否则仅在右子树搜索。若节点是叶节点，检索查询范围内的所有条目。最近邻搜索也可通过k - d树高效完成，但过程更复杂。
 - **扩展结构**：k - d - B树是k - d树的扩展，允许每个内部节点有多个子节点，类似于B树对二叉树的扩展，降低了树的高度，更适合辅助存储，上述范围搜索方法可轻松扩展到k - d - B树，最近邻查询也能高效处理。

#### R树（R - tree）
 - **结构特点**：R树是一种平衡树结构，用于对跨越空间区域的对象（如线段、矩形和其他多边形以及点）进行索引。与B⁺树类似，索引对象存储在叶节点，但每个树节点关联一个矩形边界框（bounding box） 。叶节点的边界框是包含该叶节点中所有对象的与坐标轴平行的最小矩形，内部节点的边界框是包含其子节点边界框的与坐标轴平行的最小矩形，对象（如多边形）的边界框定义为包含该对象的与坐标轴平行的最小矩形。每个内部节点存储子节点的边界框以及指向子节点的指针，叶节点存储索引对象。
 - **优势与不足**：与一些存储多边形和线段的替代结构（如R* - 树和区间树）不同，R树每个对象只存储一份副本，且能确保每个节点至少半满，但查询时可能需要搜索多条路径，导致查询速度比某些替代结构慢。不过，由于其存储效率较高且与B树相似，在支持空间数据的数据库系统中很受欢迎。

#### 位图索引（Bitmap Indices）
 - **原理基础**：位图索引是一种专门为方便多键查询设计的索引类型，尽管每个位图索引基于单个键构建。使用位图索引时，关系中的记录必须从0开始顺序编号，若记录大小固定且分配在文件的连续块中，可轻松将记录编号转换为块编号和块内记录编号。位图是简单的位数组，关系 $r$ 的属性 $A$ 的位图索引由属性 $A$ 每个可能值对应的一个位图组成，每个位图的位数与关系中的记录数相同，值 $v_j$ 对应的位图的第 $i$ 位若为1 ，表示编号为 $i$ 的记录属性 $A$ 的值为 $v_j$ ，其他位为0 。
 - **查询应用**：当对多个键进行选择时位图索引很有用。例如，对于查询“选择收入在10,000到19,999之间的女性”（`select * from instructor_info where gender = 'f' and income_level = 'L2';` ），获取 `gender` 值为 `f` 的位图和 `income_level` 值为 `L2` 的位图，对两个位图执行交集（逻辑与）操作，计算出新位图，新位图中第 
 $i$ 位为1表示两个原始位图的第 $i$ 位都为1 ，否则为0 。系统通过查找交集中值为1的位并检索相应记录来计算查询结果。

### 时间数据索引及索引相关总结
#### 时间数据索引（Indexing Temporal Data）
 - **时间数据特点**：时间数据指关联时间段的数据，元组关联的时间段表示其有效时间。一个事实的有效时间可能由多个时间间隔组成，可将其表示为多个元组，每个元组的有效时间为单个时间间隔。时间间隔有开始时间和结束时间，且需表明在开始和结束时间处是闭区间（包含该时间点）还是开区间（不包含该时间点） ，表示元组当前有效直到下次更新时，结束时间概念上设为无穷大（可用一个很大的时间值表示，如9999 - 12 - 31午夜 ）。
 - **索引方案**：
    - **使用空间索引**：检索给定属性 $a$ 值为 $v$ 、时间点为 $t_1$ 的元组值时，可创建属性 $a$ 的索引，但当搜索键值的时间间隔较多时，该索引可能检索出时间间隔不包含 $t_1$ 的元组。更好的方案是使用空间索引（如R树） ，将索引元组视为二维，一维是索引属性 $a$ ，另一维是时间维度，元组形成线段，属性 $a$ 值为 $v$ ，元组有效时间间隔为时间维度的间隔。处理R树用于时间数据索引时结束时间可能为无穷大的问题，可将当前元组（结束时间为无穷大）和非当前元组分别存储在不同索引中，当前元组索引可采用基于 $(a, start\_time)$ 的B⁺树索引（ $a$ 为索引属性，$start\_time$ 为开始时间 ），非当前元组索引采用R树等空间索引。查询时需在两个索引中搜索，对当前元组索引执行简单范围查询查找 $a = v$ 且 $start\_ts \leq t_i$ 的元组，时间范围查询处理方式类似。
    - **使用专门索引**：可使用专门为索引单维间隔设计的索引（如区间B⁺树） ，相比R树索引能提供更好的复杂度保证，但多数数据库实现更倾向使用R树索引，因其实现相对简单。主键属性的时间索引可在插入新元组或更新现有元组有效时间间隔时，高效判断时间主键约束是否被违反。

#### 索引相关总结（Summary）
 - **索引作用**：许多查询仅涉及文件中一小部分记录，为减少搜索这些记录的开销，可构建存储数据库文件的索引。
 - **索引类型**：
    - **密集索引和稀疏索引**：密集索引包含每个搜索键值的条目，稀疏索引仅包含部分搜索键值的条目。
    - **聚簇索引和非聚簇索引**：搜索键排序顺序与关系排序顺序匹配的索引为聚簇索引，其他索引为非聚簇索引或辅助索引。辅助索引可提高使用非聚簇索引搜索键的查询性能，但会增加数据库修改开销。
 - **索引顺序文件**：索引顺序文件是数据库系统中最早使用的索引方案之一，为按搜索键顺序快速检索记录，记录按序存储，无序记录链接在一起，为实现快速随机访问使用索引结构，但其性能随文件增长而下降，可使用B⁺树索引克服此缺陷。
 - **B⁺树索引**：
    - **结构特点**：B⁺树索引是平衡树，从根到叶的每条路径长度相同，树高与关系中记录数的以 $N$ 为底的对数成正比（每个非叶节点存储 $N$ 个指针，$N$ 通常约为50或100 ），比其他平衡二叉树结构短，磁盘访问次数少。
    - **操作特点**：B⁺树查找直接高效，插入和删除较复杂但仍高效，查找、插入和删除操作次数与关系中记录数的以 $N$ 为底的对数成正比。可用于索引包含记录的文件，也可将记录组织到文件中。
 - **B树索引**：B树索引与B⁺树索引类似，主要优点是消除搜索键值的冗余存储，主要缺点是整体复杂度高且给定节点大小下扇出减少，实际中系统设计者大多偏好B⁺树索引。
 - **哈希索引**：哈希是在内存和基于磁盘系统中广泛用于构建索引的技术。
 - **多属性索引**：B⁺树等有序索引可用于基于单属性等值条件的选择操作，多属性选择条件下，可对从多个索引检索到的记录标识符取交集。
 - **高写入负载索引结构**：基本B⁺树结构不适合每秒需支持大量随机写入/插入的应用，针对高写入/插入负载工作负载，提出了日志结构合并树和缓冲树等替代索引结构。
 - **位图索引**：位图索引为索引属性值极少不同的情况提供紧凑表示，位图交集操作极快，适合支持多属性查询。
 - **空间数据索引**：R树是B树的多维扩展，其变体（如R⁺树和R* - 树 ）在空间数据库中很受欢迎。四叉树等按规则划分空间的索引结构有助于处理空间连接查询。
>日期：5.23  
课后习题选做  
#### 14.16
当关系中的记录在搜索键上不是有序存储，或者关系中存在大量不同的搜索键值，且需要频繁进行精确匹配查询时，更适合使用密集索引。因为密集索引为每个搜索键值都创建一个条目，能直接定位到记录，在上述情况下查询效率高。而稀疏索引只对部分搜索键值创建条目，适用于记录按搜索键有序存储且搜索键值重复度较高的情况，此时稀疏索引能节省空间，但对于无序记录或高离散度搜索键值的精确匹配查询效率低。

#### 14.17
 - **聚簇索引（clustering index）**：搜索键的排序顺序与关系的排序顺序相匹配。在聚簇索引中，具有相近搜索键值的记录在物理存储上也较为接近。这意味着通过聚簇索引访问数据时，磁盘I/O可能更高效，因为相关记录可能存储在相邻的磁盘块中。
 - **辅助索引（secondary index）**：搜索键顺序与关系的排序顺序不同，也称为非聚簇索引。辅助索引可以提高基于非聚簇索引搜索键的查询性能，但由于其搜索键顺序与关系物理存储顺序不一致，在数据库进行修改操作（如插入、删除、更新）时，可能需要额外的开销来维护索引。

#### 14.18
由于未给出Exercise 14.3中B⁺树的具体结构，以下是一般步骤：
 - **a. 查找搜索键值为11的记录**
    - 从根节点开始，根据节点中搜索键值的范围，判断应该进入哪个子节点。例如，如果根节点有两个子节点，一个子节点的搜索键值范围是小于10，另一个是大于等于10，那么就进入大于等于10的子节点。
    - 重复上述步骤，在后续节点中继续查找，直到到达叶节点。
    - 在叶节点中遍历条目，找到搜索键值为11的记录指针，通过指针获取对应记录。
 - **b. 查找搜索键值在7（包含）和17（包含）之间的记录**
    - 从根节点开始，确定第一个可能包含范围内记录的子节点。例如，若根节点有子节点范围分别是小于5、5 - 10、大于10，那么选择5 - 10这个子节点开始查找。
    - 到达叶节点后，从叶节点中找到第一个满足范围的记录（键值为7或大于等于7的第一个记录） ，然后沿着叶节点的链表顺序查找，直到找到键值大于17的记录为止，过程中收集满足范围的记录指针，通过指针获取对应记录。

#### 14.19
向搜索键添加额外属性来处理非唯一搜索键，可能会增加搜索键的大小。在B⁺树中，每个节点能容纳的条目数与搜索键大小有关。搜索键变大可能导致每个非叶节点能存储的指针（条目）数量减少。根据B⁺树高度与节点条目数的关系，节点条目数减少可能会使B⁺树的高度增加。因为B⁺树高度与关系中记录数的以每个非叶节点存储指针数为底的对数相关，指针数减少，在记录数不变的情况下，树高可能增加，从而影响查询、插入和删除操作的I/O开销。 

#### 14.20
 - **a. 查找满足 $10 < A < 50$ 的记录的最坏情况开销**
在B⁺树中，查找操作最坏情况下需要从根节点遍历到叶节点，树的高度为 $h$ ，这意味着需要进行 $h$ 次磁盘I/O来定位到叶节点。到达叶节点后，需要遍历满足 $10 < A < 50$ 的记录，假设满足条件的记录数为 $n_1$ ，那么这部分的开销与 $n_1$ 相关（可能涉及 $n_1$ 次记录读取等操作 ）。所以最坏情况开销为 $h$ 次定位叶节点的磁盘I/O加上处理 $n_1$ 条记录的开销。
 - **b. 查找满足 $10 < A < 50 \land 5 < B < 10$ 的记录的最坏情况开销**
首先同样需要 $h$ 次磁盘I/O定位到叶节点（与a中定位到满足 $10 < A < 50$ 的叶节点过程相同 ）。然后在叶节点中筛选满足 $5 < B < 10$ 的记录，假设满足此条件的记录数为 $n_2$ 。所以最坏情况开销为 $h$ 次定位叶节点的磁盘I/O加上处理 $n_1$ 条满足 $10 < A < 50$ 记录的开销，再加上从 $n_1$ 条记录中筛选出 $n_2$ 条满足 $5 < B < 10$ 记录的开销。
 - **c. 索引高效的条件**
当 $n_2$ 相对于 $n_1$ 较小时，即满足 $10 < A < 50$ 但不满足 $5 < B < 10$ 的记录数较多时，索引是高效的。因为此时通过索引先定位到满足 $10 < A < 50$ 的记录（开销与 $n_1$ 相关 ），再从这些记录中筛选出满足 $5 < B < 10$ 的记录（开销与 $n_2$ 相关 ），相比于全表扫描（不使用索引 ），可以避免扫描大量不满足 $10 < A < 50$ 的记录，从而提高查询效率。如果 $n_2$ 接近 $n_1$ ，那么索引带来的优势不明显，甚至可能因为索引维护等开销导致整体效率不如全表扫描。 




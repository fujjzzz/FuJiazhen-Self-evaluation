本周阅读**Database-System-Concepts-7th-Edition**:PART THREE APPLICATION DESIGN AND DEVELOPMENT,知识点总结如下：  
**Chapter 8 Complex Data Types**(p365-401)  
>日期：4.8
### 半结构化数据的动机
 - **存储**：关系数据模型在支持现代应用存储需求时存在局限，半结构化数据模型可应对模式常变化、数据复杂的情况。
 - **数据交换**：在构建信息系统（如创建Web服务、开发移动应用或浏览器端代码）时，高效交换和处理复杂数据至关重要，JSON和XML是广泛采用的数据模型。

### 半结构化数据模型概览
 - **灵活模式**
    - **宽列数据表示**：数据库系统中，元组属性集不固定，每个元组属性可不同，按需添加新属性。
    - **稀疏列表示**：属性集固定但数量多，元组按需使用属性，其余为null值 。
 - **多值数据类型**
    - 允许属性包含非原子值，如集合、多重集合、数组等。例如用户兴趣主题可存为集合 ；电商产品规格可用键值对映射表示，像{ (brand, Apple), (ID, MacBook Air), (size, 13), (color, silver) } 。
    - 数组在科学（如图像存储，本质是像素值二维数组 ）和监控应用（如传感器读数 ）中重要，相关数据库（如Oracle GeoRaster、PostGIS等 ）提供对数组的专门支持。
 - **嵌套数据类型**：属性可结构化，类似E - R模型复合属性，支持集合、数组、映射等多值数据类型，形成层次结构，即嵌套数据类型 。JSON和XML是广泛使用的、允许值有复杂内部结构且模式灵活的数据表示形式。

### JSON
 - **定义与支持类型**：JavaScript对象表示法，是复杂数据类型文本表示，用于应用间数据传输和复杂数据存储，支持整数、实数、字符串基本数据类型，以及数组和对象（属性名 - 值对集合 ） 。
 - **示例特点**：对象无需遵循固定模式，类似键值映射；数组用方括号表示，可看作从整数偏移量到值的映射 。
 - **应用场景与优势**：是应用和Web服务间通信主要数据表示形式，现代应用借助Web服务存储和检索数据、在后端计算，JSON能表示复杂结构且结构灵活，适配此类应用 。
 - **相关工具与优化**：有诸多库方便在JSON表示和编程语言（如JavaScript、Java等 ）对象表示间转换；JSON文本解析耗CPU，压缩表示（如BSON ）流行；SQL语言扩展支持JSON表示，可将JSON数据存储为JSON数据类型，也能从关系数据生成JSON数据。

### XML
XML数据表示法在文本表示中添加了尖括号括起来的标签 `<>` 来标记信息。标签成对使用，`<tag>` 和 `</tag>` 界定标签所指文本部分的开始和结束。例如，文档标题可能如下标记：
```xml
<title>Database System Concepts</title>
```
这样的标签可用于表示关系数据，将关系名和属性名指定为标签，如下所示：
```xml
<course>
    <course_id> CS-101 </course_id>
    <title> Intro. to Computer Science </title>
    <dept_name> Comp. Sci. </dept_name>
    <credits> 4 </credits>
</course>
```
```xml
<purchase_order>
    <identifier> P-101 </identifier>
    <purchaser>
        <name> Cray Z. Coyote </name>
        <address> Route 66, Mesa Flats, Arizona 86047, USA </address>
    </purchaser>
    <supplier>
        <name> Acme Supplies </name>
        <address> 1 Broadway, New York, NY, USA </address>
    </supplier>
    <itemlist>
        <item>
            <identifier> RS1 </identifier>
            <description> Atom powered rocket sled </description>
            <quantity> 2 </quantity>
            <price> 199.95 </price>
        </item>
        <item>
            <identifier> SG2 </identifier>
            <description> Superb glue </description>
            <quantity> 1 </quantity>
            <unit-of-measure> liter </unit-of-measure>
            <price> 29.95 </price>
        </item>
    </itemlist>
    <total_cost> 429.85 </total_cost>
    <payment_terms> Cash-on-delivery </payment_terms>
    <shipping_mode> 1-second-delivery </shipping_mode>
</purchase_order>
```
与关系模式不同，XML可轻松引入新标签，并且通过合适的名称，数据具有 “自描述性”，人们可以根据名称理解或猜测特定数据的含义。此外，标签可用于创建层次结构，这在关系模型中是不可能的。层次结构对于表示组织间必须交换的业务对象特别重要，例如账单、采购订单等。图8.2展示了采购订单信息如何用XML表示，说明了XML更实际的应用。采购订单通常由一个组织生成并发送给另一个组织。采购订单包含各种信息；嵌套表示允许采购订单中的所有信息自然地表示在单个文档中（实际采购订单包含的信息比这个简化示例多得多）。XML提供了标记数据的标准方法；当然，两个组织必须就采购订单中出现的标签及其含义达成一致。

为支持XML数据查询，开发了XQuery语言。XML和XQuery的更多详细信息可在第30章中找到。尽管有多个供应商提供XQuery实现，但与SQL不同，XQuery的采用相对有限。不过，SQL语言本身在以下几个方面进行了扩展以支持XML：
- XML数据可以存储为XML数据类型。
- SQL查询可以从关系数据生成XML数据。这样的扩展对于将相关数据打包到一个XML文档中非常有用，然后可以将该文档发送到另一个应用程序。这些扩展允许从单个行构建XML表示，以及使用XMLAGG聚合函数从行集合创建XML文档。 
- SQL查询可以从XML数据类型值中提取数据。例如，XPath语言支持 “路径表达式”，允许从XML文档中提取所需的数据部分。

更多关于这些扩展的详细信息可在第30章中找到。

### 8.1.4 RDF和知识图谱
资源描述框架（Resource Description Framework，RDF）是一种基于实体 - 关系模型的数据表示标准。本节将对RDF进行概述。

#### 8.1.4.1 三元组表示
RDF模型通过一组三元组表示数据，三元组有以下两种形式：
1. `(ID, attribute-name, value)`
2. `(ID1, relationship-name, ID2)`

其中，`ID`、`ID1` 和 `ID2` 是实体的标识符；在RDF中，实体也称为资源。请注意，与E - R模型不同，RDF模型仅支持二元关系，不支持更一般的n元关系；我们稍后会回到这个问题。三元组的第一个属性称为主语（subject），第二个属性称为谓语（predicate），最后一个属性称为宾语（object）。因此，一个三元组具有 `(subject, predicate, object)` 的结构。

图8.3展示了大学数据库一小部分的三元组表示。所有属性值都用引号括起来，而标识符则不用引号。属性和关系名称（构成每个三元组的谓语部分）也不用引号。

在我们的示例中，我们使用ID值来标识教师和学生，使用 `course_id` 来标识课程。它们的每个属性都表示为一个单独的三元组。对象的类型信息由 `instance-of` 关系提供；例如，10101被标识为教师的实例，而00128是学生的实例。为遵循RDF语法，计算机科学系的标识符表示为 `comp_sci`。只显示了该系的一个属性 `dept_name`。由于 `section` 的主键是复合键，我们创建了新的标识符来标识 `section`；“sec1” 标识这样一个 `section`，并显示了它的 `semester`、`year` 和 `sec_id` 属性，以及与CS - 101课程的 `course` 关系。

图中显示的关系包括大学模式中出现的 `takes` 和 `teaches` 关系。教师、学生和课程所属的系分别显示为 `inst_dept`、`stud_dept` 和 `course_dept` 关系，遵循E - R模型；类似地，与 `section` 关联的教室也显示为与教室对象（在我们的示例中为 `packard-101`）的 `classroom` 关系，与 `section` 关联的课程显示为 `section` 和课程之间的 `sec_course` 关系。

如我们所见，实体类型信息使用实体与表示类型的对象之间的 `instance-of` 关系来表示；类型 - 子类型关系也可以表示为类型对象之间的 `subtype` 边。

与E - R模型和关系模式相比，RDF允许轻松向对象添加新属性，也可以创建新类型的关系。
  
>日期：4.10
#### 8.1.4.2 RDF的图表示
RDF表示具有非常自然的图解释。实体和属性值可以视为节点，属性名和关系可以视为节点之间的边。属性/关系名称可以视为相应边的标签。图8.4展示了图8.3数据的图表示。对象显示为椭圆形，属性值显示为矩形，关系显示为带有标识关系的关联标签的边。为简洁起见，我们省略了 `instance-of` 关系。

使用RDF图模型（或其变体和扩展）表示信息称为知识图谱（knowledge graph）。知识图谱有多种用途。其中一个应用是存储从各种数据源（如维基百科、Wikidata和网络上的其他来源）收集的事实。例如，“华盛顿特区是美国的首都” 这样的事实可以表示为一条标记为 `capital-of` 的边，连接两个节点，一个表示实体华盛顿特区，另一个表示实体美国。  

### 8.1.4.3 SPARQL
SPARQL是一种为查询RDF数据而设计的查询语言。该语言基于三元组模式，这些模式看起来像RDF三元组，但可能包含变量。例如，三元组模式：
```
?cid title "Intro. to Computer Science"
```
将匹配所有谓语为 “title” 且宾语为 “Intro. to Computer Science” 的三元组。这里，`?cid` 是一个可以匹配任何值的变量。

查询可以有多个三元组模式，变量可在三元组之间共享。考虑以下三元组对：
```
?cid title "Intro. to Computer Science"
?sid course ?cid
```
在图8.3所示的大学三元组数据集上，第一个三元组模式匹配三元组 `(CS-101, title, "Intro. to Computer Science")`，而第二个三元组模式匹配 `(sec1, course, CS-101)`。共享变量 `?cid` 对这两个三元组模式强制执行连接条件。

下面展示一个完整的SPARQL查询，该查询检索修读了课程名为 “Intro. to Computer Science” 的课程的所有学生的姓名：
```sparql
select ?name
where {
    ?cid title "Intro. to Computer Science".
    ?sid course ?cid.
    ?id takes ?sid.
    ?id name ?name.
}
```
这些三元组之间的共享变量对匹配每个三元组的元组强制执行连接条件。

请注意，与SQL不同，三元组模式中的谓语可以是变量，它可以匹配任何关系或属性名。SPARQL还有许多其他功能，如聚合、可选连接（类似于外连接）和子查询。有关SPARQL的更多信息，请参阅 “进一步阅读” 中的参考文献。

### 8.1.4.4 表示n元关系
表示为边的关系只能建模二元关系。知识图谱已被扩展以存储更复杂的关系。例如，知识图谱已扩展了时间信息，以记录一个事实为真的时间段；如果美国的首都在2050年从华盛顿特区变为纽约，这将由两个事实表示，一个是华盛顿为首都到2050年结束的时间段，另一个是2050年之后的时间段。

如6.9.4节所述，n元关系可以通过创建与n元关系中的元组对应的人工实体，并将该人工实体链接到参与关系的每个实体，用二元关系来表示。在前述示例中，我们可以创建一个人工实体 $e_1$ 来表示巴拉克·奥巴马在2008年至2016年担任美国总统这一事实。我们通过 `person` 和 `country` 关系边分别将 $e_1$ 链接到表示奥巴马和美国的实体，并通过属性边 `president-from` 和 `president-till` 分别链接到值2008和2016。如果我们选择将年份表示为实体，上述创建的到这两个年份的边将表示关系而不是属性。

上述想法类似于E - R模型中的聚合概念（如6.8.5节所述，它可以将关系视为实体）；在RDF中，这个想法称为具体化（reification）。具体化在许多知识图谱表示中使用，其中诸如有效期等额外信息被视为基础边的限定词（qualifiers）。

其他模型在三元组中添加了第四个属性，称为上下文（context）；因此，它们存储的不是三元组，而是四元组（quads）。基本关系仍然是二元的，但第四个属性允许上下文实体与关系相关联。诸如有效期等信息可以作为上下文实体的属性来处理。

有几个知识图谱，如Wikidata、DBPedia、Freebase和Yago，它们提供了各种知识的RDF/知识图谱表示。此外，还有大量特定领域的知识图谱。链接开放数据（linked open data）项目旨在使各种此类知识图谱开源，并进一步在这些独立创建的知识图谱之间创建链接。这些链接允许查询使用来自多个知识图谱的信息以及到知识图谱的链接进行推理。关于该主题的更多信息参考文献可在本章的参考书目注释中找到，可在线获取。

### 8.2 面向对象
对象 - 关系数据模型通过提供更丰富的类型系统（包括复杂数据类型和面向对象特性）扩展了关系数据模型。关系查询语言，特别是SQL，也相应地进行了扩展以处理更丰富的类型系统。这些扩展试图在保留关系基础（特别是声明式数据访问）的同时扩展建模能力。

许多数据库应用程序是使用面向对象编程语言（如Java、Python或C++）编写的，但它们需要从数据库中存储和获取数据。由于面向对象编程语言的原生类型系统与数据库支持的关系模型之间存在类型差异，每当数据被获取或存储时，都需要在这两个模型之间进行转换。仅仅扩展数据库支持的类型系统并不能完全解决这个问题。使用与编程语言不同的语言（SQL）来表达数据库访问，又会使程序员的工作更加困难。对于许多应用程序来说，希望有编程语言结构或扩展，允许直接访问数据库中的数据，而无需通过诸如SQL这样的中间语言。

在实践中，有三种方法用于将面向对象特性与数据库系统集成：
1. 构建对象 - 关系数据库系统，即在关系数据库系统中添加面向对象特性。
2. 根据指定的对象 - 关系映射，自动将数据从编程语言的原生面向对象类型系统转换为关系表示以进行存储，反之亦然以进行检索。 
3. 构建面向对象数据库系统，即原生支持面向对象类型系统并允许使用编程语言的原生类型系统从面向对象编程语言直接访问数据的数据库系统。

本节将简要介绍前两种方法。虽然第三种方法（面向对象数据库方法）在语言集成方面比前两种方法有一些优势，但由于两个原因，它并没有取得很大成功。首先，声明式查询对于高效访问数据非常重要，而命令式编程语言不支持这种查询。其次，通过指针直接访问对象被发现会因指针错误而增加数据库损坏的风险。我们不再进一步描述面向对象方法。

#### 8.2.1 对象 - 关系数据库系统
在本节中，我们概述如何将面向对象特性添加到关系数据库系统中。

##### 8.2.1.1 用户定义类型
SQL的对象扩展允许创建结构化的用户定义类型、对这些类型的引用以及包含这些类型元组的表。
```sql
create type Person
(
    ID varchar(20) primary key,
    name varchar(20),
    address varchar(20)
)
ref from(ID);
create table people of Person;
```
我们可以如下创建一个新的人员记录：
```sql
insert into people (ID, name, address) values
('12345', 'Srinivasan', '23 Coyote Run');
```
许多数据库系统支持数组和表类型；关系的属性和用户定义类型的属性可以声明为这种数组或表类型。不同数据库系统对这些特性的支持以及语法差异很大。例如，在PostgreSQL中，`integer[]` 表示大小未预先指定的整数数组，而Oracle支持语法 `varray(10) of integer` 来指定10个整数的数组。SQL Server允许按以下示例声明表值类型：
```sql
create type interest as table (
    topic varchar(20),
    degree_of_interest int
);
create table users (
    ID varchar(20),
    name varchar(20),
    interests interest
);
```
用户定义类型也可以关联方法。只有少数数据库系统（如Oracle）支持此功能，我们省略详细信息。

##### 8.2.1.2 类型继承
考虑前面定义的 `Person` 类型和 `people` 表。我们可能希望在数据库中存储关于学生和教师的额外信息。由于学生和教师也是人，我们可以在SQL中使用继承来定义学生和教师类型：
```sql
create type Student under Person
(degree varchar(20));
create type Teacher under Person
(salary integer);
```
`Student` 和 `Teacher` 都继承 `Person` 的属性，即 `ID`、`name` 和 `address`。`Student` 和 `Teacher` 被称为 `Person` 的子类型，而 `Person` 是 `Student` 和 `Teacher` 的超类型。

结构化类型的方法也被子类型继承，就像属性一样。然而，子类型可以重新定义方法的效果。我们省略详细信息。

##### 8.2.1.3 表继承
表继承允许将一个表声明为另一个表的子表，这对应于E - R模型中的特化/泛化概念。一些数据库系统支持表继承，但方式不同。

在PostgreSQL中，我们可以创建一个 `people` 表，然后将 `students` 和 `teachers` 表作为 `people` 的子表创建如下：
```sql
create table students
(degree varchar(20))
inherits people;
create table teachers
(salary integer)
inherits people;
```
### 8.3.1 关键词查询
信息检索系统支持检索包含所需信息文档的功能。所需文档通常由一组关键词来描述。例如，关键词 “database system” 可用于定位有关数据库系统的文档，关键词 “stock” 和 “scandal” 可用于定位有关股市丑闻的文章。文档都关联有一组关键词，通常文档中的所有单词都被视为关键词。关键词查询检索其关键词集合包含查询中所有关键词的文档。

在最简单的形式中，信息检索系统查找并返回包含查询中所有关键词的文档。更复杂的系统会评估文档与查询的相关性，以便按估计的相关程度顺序显示文档。它们使用有关关键词出现的信息以及超链接信息来估计相关性。

关键词搜索最初针对组织内的文档存储库或特定领域的文档存储库（如研究出版物）。但信息检索对于存储在数据库中的文档也很重要。

基于关键词的信息检索不仅可用于检索文本数据，还可用于检索其他类型的数据，如视频和音频数据，这些数据都有关联的描述性关键词。例如，一部电影可能有关联的关键词，如标题、导演、演员和类型，而图像或视频剪辑可能有关联的标签，这些标签是描述图像或视频剪辑的关键词。

网络搜索引擎本质上是信息检索系统。它们通过爬取网络来检索和存储网页。用户提交关键词查询，搜索引擎的信息检索部分查找存储的包含所需关键词的网页。如今，网络搜索引擎的功能已不仅仅是检索网页。搜索引擎旨在通过判断查询的主题来满足用户的信息需求，不仅显示被判定为相关的网页，还显示有关该主题的其他类型信息。例如，对于查询词 “cricket”，搜索引擎可能会显示正在进行或近期板球比赛的比分，而不仅仅是与板球相关的排名靠前的文档。再如，对于查询 “New York”，搜索引擎除了显示与纽约相关的网页外，还可能显示纽约的地图和图像。

### 8.3.2 相关性排名
包含查询中关键词的所有文档集合可能非常大。特别是网络上有数十亿个文档，在网络搜索引擎上的大多数关键词查询会找到包含部分或全部关键词的数十万甚至更多文档。并非所有文档与关键词查询的相关性都相同。因此，信息检索系统会评估文档与查询的相关性，并仅返回排名靠前的文档作为答案。相关性排名并非一门精确科学，但有一些被广泛接受的方法。
  
>日期：4.12
### 8.2.1.4 SQL中的引用类型
一些SQL实现（如Oracle）支持引用类型。例如，我们可以如下定义 `Person` 类型，并声明引用类型：
```sql
create type Person
(
    ID varchar(20) primary key,
    name varchar(20),
    address varchar(20)
)
ref from(ID);
create table people of Person;
```
默认情况下，SQL为元组分配系统定义的标识符，但现有的主键值可通过在类型定义中包含 `ref from` 子句来引用元组，如上所示。

我们可以定义一个 `Department` 类型，它有一个 `name` 字段和一个 `head` 字段，`head` 是对 `Person` 类型的引用。然后我们可以创建一个 `departments` 表，类型为 `Department`，如下：
```sql
create type Department (
    dept_name varchar(20),
    head ref(Person) scope people
);
create table departments of Department;
```
请注意，上面的 `scope` 子句完成了从 `departments.head` 到 `people` 关系的外键定义。

向 `departments` 表插入元组时，我们可以使用：
```sql
insert into departments
values ('CS', '12345');
```
因为 `ID` 属性用作对 `Person` 的引用。或者，`Person` 的定义可以指定在创建 `Person` 对象时，引用必须由系统自动生成。系统生成的标识符可以使用 `ref(r)` 检索，其中 `r` 是查询中使用的表名或表别名。因此，我们可以创建一个 `Person` 元组，并使用人的 `ID` 或姓名，在子查询中检索对该元组的引用，在向 `departments` 表插入元组时，该引用用于创建 `head` 属性的值。由于大多数数据库系统不允许在 `insert into departments values` 语句中使用子查询，因此可以使用以下两个查询来完成该任务：
```sql
insert into departments
values ('CS', null);
update departments
set head = (select ref(p)
            from people as p
            where ID = '12345')
where dept_name = 'CS';
```
在SQL:1999中，通过 `->` 符号对引用进行解引用。考虑前面定义的 `departments` 表。我们可以使用以下查询查找所有部门负责人的姓名和地址：
```sql
select head->name, head->address
from departments;
```
像 “`head->name`” 这样的表达式称为路径表达式。

由于 `head` 是对 `people` 表中元组的引用，上述查询中的 `name` 属性是 `people` 表中元组的 `name` 属性。引用可用于隐藏连接操作；在上述示例中，如果没有引用，`department` 的 `head` 字段将被声明为 `people` 表的外键。要查找部门负责人的姓名和地址，我们需要显式连接 `departments` 和 `people` 关系。引用的使用大大简化了查询。

我们可以使用 `deref` 操作返回引用指向的元组，然后访问其属性，如下所示：
```sql
select deref(head).name
from departments;
```

### 8.2.2 对象 - 关系映射
对象 - 关系映射（Object-relational mapping，ORM）系统允许程序员定义数据库关系中的元组与编程语言中的对象之间的映射。

可以根据对象属性上的选择条件检索单个对象或一组对象；根据选择条件从底层数据库检索相关数据，并根据对象与关系之间预先指定的映射，从检索到的数据创建一个或多个对象。

程序可以更新检索到的对象、创建新对象或指定删除某个对象，然后发出保存命令；从对象到关系的映射随后用于相应地更新、插入或删除数据库中的元组。

对象 - 关系映射系统的主要目标是减轻程序员构建应用程序的工作负担，为他们提供对象模型，同时保留使用强大的关系数据库的优势。此外，当对缓存于内存中的对象进行操作时，对象 - 关系系统与直接访问底层数据库相比，可显著提高性能。

对象 - 关系映射系统还提供查询语言，允许程序员直接在对象模型上编写查询；此类查询会被转换为对底层关系数据库的SQL查询，并从SQL查询结果创建结果对象。

使用ORM的一个额外好处是，可以使用多个数据库中的任何一个来存储数据，而代码保持不变。ORM从高层隐藏了数据库之间细微的SQL差异。因此，使用ORM时从一个数据库迁移到另一个数据库相对简单，而如果应用程序使用SQL与数据库通信，SQL差异会使这种迁移变得困难得多。

不利的一面是，对象 - 关系映射系统在批量更新数据库以及直接用命令式语言编写复杂查询时，可能存在显著的性能效率问题。可以绕过对象 - 关系映射系统直接更新数据库，并在发现性能低效时直接用SQL编写复杂查询。

对于许多应用程序而言，对象 - 关系模型的优点超过了缺点，并且对象 - 关系映射系统近年来得到了广泛采用。特别是，Hibernate在Java中得到了广泛应用，而包括Django和SQLAlchemy在内的多个ORM在Python中也被广泛使用。关于为Java提供对象 - 关系映射的Hibernate ORM系统以及为Python提供对象 - 关系映射的Django ORM系统的更多信息，可在9.6.2节中找到。

### 8.3 文本数据
文本数据由非结构化文本组成。术语 “信息检索” 通常是指对非结构化文本数据的查询。在信息检索领域使用的传统模型中，文本信息被组织成文档。在数据库中，文本值属性可被视为一个文档。在网络环境中，每个网页都可被视为一个文档。   

### 8.3.2.1 使用TF-IDF进行排名
术语 “term” 指的是出现在文档中或作为查询一部分给出的关键词。首先要解决的问题是，对于特定的术语 $t$，特定文档 $d$ 与该术语的相关性如何。一种方法是使用该术语在文档中的出现次数来衡量其相关性，前提是假设相关术语在文档中出现的次数可能更多。但仅仅计算一个术语的出现次数通常不是一个好的指标：首先，出现次数取决于文档的长度；其次，一个包含某个术语10次的文档，其相关性可能并非是只包含该术语1次的文档的10倍。

衡量  $TF(d, t)$ （术语  $t$  与文档  $d$  的相关性）的一种方法是：
 $\[ TF(d, t) = \log \left( 1 + \frac{n(d, t)}{n(d)} \right) \]$ 
其中  $n(d)$  表示文档中术语的出现总数， $n(d, t)$  表示术语  $t$  在文档  $d$  中的出现次数。可以看到，这个指标考虑了文档的长度。随着术语在文档中出现次数的增加，相关性也会增加，尽管并非与出现次数直接成比例。

许多系统会使用其他信息来细化上述指标。例如，如果该术语出现在标题、作者列表或摘要中，那么该文档与该术语的相关性会被认为更高。同样，如果一个术语在文档中首次出现的位置较靠后，那么该文档与该术语的相关性可能会被认为比首次出现位置靠前的文档更低。上述概念可以通过对  $TF(d, t)$  公式的扩展来形式化。在信息检索领域，无论具体使用何种公式，文档与一个术语的相关性都被称为词频（term frequency，TF）。

一个查询  $Q$  可能包含多个关键词。文档与包含两个或更多关键词的查询的相关性是通过组合相关性度量来估计的。一种简单的组合这些度量的方法是将它们相加。

然而，并非所有用作关键词的术语都同等重要。假设一个查询使用了两个术语，其中一个术语出现频率较高，如 “database”，另一个出现频率较低，如 “Silberschatz”。包含 “Silberschatz” 但不包含 “database” 的文档，其排名应该高于包含 “database” 但不包含 “Silberschatz” 的文档。

为解决这个问题，使用逆文档频率（inverse document frequency，IDF）为术语分配权重，其定义为：
 $\[ IDF(t) = \frac{1}{n(t)} \]$ 
其中  $n(t)$  表示（在系统索引的文档中）包含术语  $t$  的文档数量。那么文档  $d$  与一组术语  $Q$  的相关性定义为：
 $\[ r(d, Q) = \sum_{t \in Q} TF(d, t) * IDF(t) \]$ 
如果允许用户为查询中的术语指定权重  $w(t)$ ，则可以进一步细化此度量，在上述公式中，将  $TF(t)$  乘以  $w(t)$  时也会考虑用户指定的权重。

上述使用词频和逆文档频率来衡量文档相关性的方法称为TF-IDF方法。

几乎所有（英文）文本文档都包含诸如 “and”、“or”、“a” 等词，因此这些词对于查询目的来说毫无用处，因为它们的逆文档频率极低。信息检索系统会定义一组停用词（stop words），包含大约100个最常见的词，在为文档建立索引时会忽略这些词。这些词不会用作关键词，如果用户提供的关键词中包含这些词，也会被丢弃。

当查询包含多个术语时，另一个要考虑的因素是术语在文档中的接近程度（proximity）。如果术语在文档中彼此接近出现，那么该文档的排名会更高，而如果它们相距较远，则排名较低。可以修改  $r(d, Q)$  的公式来考虑术语的接近程度。

给定一个查询  $Q$ ，信息检索系统的任务是按与  $Q$  的相关性降序返回文档。由于可能存在大量相关文档，信息检索系统通常只返回估计相关性最高的前几个文档，并允许用户以交互方式请求更多文档。

### 8.3.2.2 使用超链接进行排名
文档之间的超链接可用于确定文档的整体重要性，而与关键词查询无关。例如，被许多其他文档链接的文档被认为更重要。

网络搜索引擎Google引入了PageRank，它是一种基于链接到页面的页面的受欢迎程度来衡量页面受欢迎程度的指标。使用PageRank受欢迎程度指标对查询结果进行排名，其结果比以前使用的排名技术要好得多，这使得Google在相当短的时间内成为使用最广泛的搜索引擎。

请注意，被许多网页指向的页面更有可能被访问，因此应该具有更高的PageRank。同样，被具有高PageRank的网页指向的页面也更有可能被访问，因此也应该具有更高的PageRank。

因此，文档  $d$  的PageRank是（循环地）基于链接到文档  $d$  的其他文档的PageRank来定义的。PageRank可以通过一组线性方程来定义，如下：首先，为网页分配整数标识符。跳转概率矩阵  $T$  定义为， $T[i, j]$  设置为从页面  $i$  出发的随机浏览者跟随链接到页面  $j$  的概率。假设从  $i$  出发的每个链接被跟随的概率相等， $T[i, j] = 1/N_i$ ，其中  $N_i$  是页面  $i$  上的链接数量。那么每个页面  $j$  的PageRank  $P[j]$  可以定义为：
 $\[ P[j] = \delta / N + (1 - \delta) * \sum_{i = 1}^{N} (T[i, j] * P[i]) \]$ 
其中  $\delta$  是介于0和1之间的常数，通常设置为0.15， $N$  是页面数量。

上述生成的方程组通常通过迭代技术求解，初始时将每个  $P[i]$  设置为  $1/N$ 。迭代的每一步都使用上一次迭代的  $P$  值为每个  $P[i]$  计算新值。当一次迭代中任何 
 $P[i]$  值的最大变化低于某个截止值时，迭代停止。

请注意，PageRank是一种静态度量，与关键词查询无关；给定一个关键词查询，它与文档的TF-IDF分数结合使用，以判断文档与关键词查询的相关性。

PageRank不是衡量网站受欢迎程度的唯一指标。有关网站被访问频率的信息是另一种有用的受欢迎程度衡量指标。此外，搜索引擎会跟踪用户在将页面作为答案返回时点击该页面的比例。出现在指向页面的超链接的锚文本中的关键词被视为非常重要，并赋予更高的词频。这些以及许多其他因素都用于对关键词查询的结果进行排名。

### 8.3.3 衡量检索效果
关键词查询结果的排名并非一门精确科学。有两个指标用于衡量信息检索系统回答查询的效果。第一个是精确率（precision），它衡量检索到的文档中实际与查询相关的文档所占的百分比。第二个是召回率（recall），它衡量相关文档中被检索到的文档所占的百分比。由于搜索引擎会找到大量答案，并且用户通常在浏览一定数量（例如10个或20个）答案后就会停止，因此精确率和召回率通常在 “@K” 下衡量，其中  $K$  是查看的答案数量。因此，我们可以说精确率@10或召回率@20。

### 8.3.4 结构化数据和知识图谱上的关键词查询
虽然对结构化数据的查询通常使用诸如SQL这样的查询语言来完成，但不熟悉模式或查询语言的用户会发现很难从这些数据中获取信息。基于在从网络进行信息检索的背景下关键词查询的成功，已经开发出技术来支持对结构化和半结构化数据的关键词查询。

一种方法是使用图来表示数据，然后在图上执行关键词查询。例如，元组可以被视为图中的节点，元组之间的外键和其他连接可以被视为图中的边。关键词搜索随后被建模为在相应图中找到包含给定关键词的元组，并找到它们之间的连接路径。

例如，在大学数据库上的查询 “Zhang Katz” 可能会找到在学生元组中出现的名字 “Zhang”，以及在教师元组中出现的名字 “Katz”，并通过导师关系找到连接这两个元组的路径。作为对此查询的响应，也可能找到其他路径，例如学生 “Zhang” 选修了 “Katz” 教授的课程。当用户不知道确切的模式并且不想费力编写定义其搜索内容的SQL查询时，此类查询可用于临时浏览和查询数据。确实，期望普通用户使用结构化查询语言编写查询是不合理的，而关键词查询则相当自然。

由于查询未完全定义，因此可能有许多不同类型的答案，需要对这些答案进行排名。已经提出了许多技术来在这种情况下对答案进行排名，这些技术基于连接路径的长度以及为边分配方向和权重的技术。还提出了基于外键链接为元组分配受欢迎程度排名的技术。有关结构化数据关键词搜索的更多信息，请参阅本章的参考书目注释，可在线获取。

此外，知识图谱可与文本信息一起用于回答查询。例如，知识图谱可用于为实体提供唯一标识符，这些标识符用于注释文本文档中对实体的提及。现在，文档中对一个人的特定提及可能会有短语 “Stonebraker开发了PostgreSQL”；从上下文中，可以推断出单词Stonebraker指的是数据库研究员 “Michael Stonebraker”，并通过将单词Stonebraker链接到实体 “Michael Stonebraker” 来进行注释。知识图谱还可能记录Stonebraker获得图灵奖这一事实。现在，对于查询 “turing award postgresql”，可以使用来自文档和知识图谱的信息来回答。

如今的网络搜索引擎除了使用爬取的文档外，还使用大型知识图谱来回答用户查询。

### 8.4 空间数据
数据库系统中的空间数据支持对于基于空间位置高效存储、索引和查询数据非常重要。

两种特别重要的空间数据类型是：
- **地理数据**：如道路地图、土地利用地图、地形高程地图、显示边界的政治地图、土地所有权地图等。地理信息系统是专门为存储地理数据而定制的专用数据库系统。地理数据基于地球坐标系统，包括纬度、经度和海拔。
- **几何数据**：包括关于建筑物、汽车或飞机等物体如何构造的空间信息。几何数据基于二维或三维欧几里得空间，具有  $X$ 、 $Y$  和  $Z$  坐标。

许多数据库系统支持地理和几何数据类型，如Oracle Spatial and Graph、PostgreSQL的PostGIS扩展、SQL Server和IBM DB2 Spatial Extender。


表示地理和几何数据的语法因数据库而异，不过现在越来越多地支持基于开放地理空间联盟（Open Geospatial Consortium，OGC）标准的表示。请参阅您使用的数据库的手册，以了解该数据库支持的特定语法。

### 8.4.1 几何信息的表示
图8.5说明了如何以规范化的方式在数据库中表示各种几何构造。这里要强调的是，几何信息可以用几种不同的方式表示，我们只描述其中一些。

线段可以用其端点的坐标来表示。例如，在地图数据库中，一个点的两个坐标将是其纬度和经度。多段线（也称为线串）由一系列连接的线段组成，可以用一个列表来表示，该列表按顺序包含线段端点的坐标。我们可以用多段线近似表示任意曲线，方法是将曲线划分为一系列线段。这种表示对于道路等二维特征很有用；在这里，道路的宽度相对于整个地图的大小足够小，可以被视为一条线。一些系统还支持圆弧作为基本元素，允许将曲线表示为圆弧序列。  
### 8.4.1 几何信息的表示
- **基本几何对象表示**
    - **线段**：用端点坐标表示，如地图数据库中用纬度和经度坐标。
    - **多段线（线串）**：由连接线段组成，用端点坐标列表顺序表示，可用于近似表示曲线，部分系统支持圆弧表示曲线。
    - **多边形**：可按顺序列出顶点表示，也可划分为三角形表示。复杂多边形划分成三角形后，各三角形携带多边形标识符，圆和椭圆可用对应类型或多边形近似表示。基于列表的多段线或多边形表示利于查询处理，若数据库支持非第一范式表示，可采用；也可给多段线或曲线分配标识符，将各线段表示为携带其标识符的独立元组，实现第一范式关系表示。
- **三维空间几何对象表示**
    - **点和线段**：与二维类似，点增加z坐标分量。
    - **平面图形（三角形、矩形等多边形）**：表示变化不大。
    - **多面体（四面体、长方体等）**：四面体和长方体可类比三角形和矩形表示；任意多面体可划分成四面体，或列出各面（多边形）及面的内侧信息表示。
- **数据库支持**：SQL Server和PostGIS等支持geometry和geography类型，包含point、linestring、curve、polygon等子类型及multipoint、multilinestring、multicurve、multipolygon等集合类型。这些类型文本表示由OGC标准定义，可通过转换函数转换为内部表示，如LINESTRING(1 1, 2 3, 4 4)定义连接点(1, 1)、(2, 3)和(4, 4)的线，POLYGON((1 1, 2 3, 4 4, 1 1))定义三角形；ST_GeometryFromText()和ST_GeographyFromText()分别转换文本表示为geometry和geography对象，ST_Union()和ST_Intersection()等函数计算几何对象并集和交集，不同系统函数名和语法有差异。
- **地图数据中的空间网络**：地图数据中表示道路的线段相互连接形成空间网络或空间图，包含图顶点空间位置及顶点间连接信息（构成边），边关联距离、车道数、不同时段平均速度等多种信息。

### 8.4.2 设计数据库
- **CAD系统数据存储演变**：传统计算机辅助设计（CAD）系统编辑时将数据存于内存，编辑结束写回文件，存在数据格式转换成本（编程复杂度和时间成本）及即使只需部分数据也需读取整个文件的问题；大规模设计（如大规模集成电路或飞机设计）难以将完整设计存于内存。面向对象数据库设计很大程度受CAD系统数据库需求推动，将设计组件表示为对象，对象连接指示设计结构。
- **设计数据库对象**
    - **几何对象**：存储对象多为几何对象。二维简单几何对象包括点、线、三角形、矩形、多边形等，复杂二维对象可由简单对象通过并、交、差运算形成；三维复杂对象可由球体、圆柱体、长方体等简单对象经并、交、差运算形成，三维表面可用线框模型（用线段、三角形、矩形等简单对象集合表示）表示。
    - **非空间信息**：也存储对象的非空间信息，如对象构成材料，通常可用标准数据建模技术处理，此处关注空间方面。
- **空间操作与约束**
    - **空间操作**：需对设计执行各种空间操作，如检索特定感兴趣区域对应设计部分，空间索引结构（见14.10.1节）对这类任务有用，其为多维结构，处理二维和三维数据，而非B⁺树的简单一维排序。
    - **空间完整性约束**：如“两根管道不应在同一位置”，在设计数据库中很重要，可防止干扰错误，人工设计常出现此类错误且原型构建时才被检测，修复成本高。数据库对空间完整性约束的支持帮助避免设计错误，保持设计一致性，实现此类完整性检查依赖高效多维索引结构。

### 8.4.3 地理数据
- **地理数据应用**
    - **在线地图和导航服务**：如今广泛应用。
    - **公共服务设施分布网络信息**：如电话、电力、供水系统等。
    - **生态和规划相关土地利用信息**：为生态学家和规划者提供。
    - **土地产权记录**：用于追踪土地所有权等众多用途。
    - **公共事业信息数据库重要性**：随地下电缆和管道网络发展，地理数据库结合GPS精确定位系统，避免因缺乏详细地图导致的公用事业工作相互损坏结构、大规模服务中断问题。
- **地理数据表示**
    - **栅格数据（Raster data）**
        - **定义与构成**：由位图或像素地图组成，可为二维或更多维。二维典型例子是区域卫星图像，除实际图像外，数据包括图像位置（如通过角落经纬度指定）和分辨率（可用像素总数或地理数据中更常见的每个像素覆盖区域指定）。
        - **瓦片表示**：常表示为瓦片（tiles），每个覆盖固定大小区域，通过显示与区域重叠瓦片展示更大区域，为支持不同缩放级别显示，为每个缩放级别创建独立瓦片集，用户界面（如网页浏览器）设置缩放级别后，检索并显示指定缩放级别与显示区域重叠的瓦片。
        - **多维拓展**：可以是三维（如不同海拔高度的温度），时间也可构成另一维度（如不同时间点的表面温度测量值）。
    - **矢量数据（Vector data）**
        - **定义与构成**：由基本几何对象构建，二维包括点、线段、多段线、三角形、多边形等，三维包括圆柱体、球体、长方体、多面体等。地理数据中，点通常用经纬度表示，涉及高度时增加海拔。
        - **地图数据表示**：地图数据常以矢量格式表示，道路常用多段线表示，大型湖泊、州和国家等地理或政治特征用复杂多边形表示，河流等特征根据宽度相关性可表示为复杂曲线或多边形。
        - **区域信息表示**：与区域相关地理信息（如年降雨量）可用数组（即栅格形式）表示，为节省空间可压缩存储，也可用四叉树等数据结构替代表示；也可用矢量形式（多边形）表示区域信息，某些应用中矢量表示比栅格更紧凑、精确（如描绘道路），但不适用于基于栅格数据的应用（如卫星图像）。
        - **地形信息表示**：地形信息（点的海拔）可用栅格形式表示，也可将表面划分为覆盖（近似）等海拔区域的多边形（每个多边形关联单一海拔值）或三角化（即划分为三角形，用三角形角落经纬度和海拔表示，称为不规则三角网（TIN）表示，特别适用于生成区域三维视图）。
    - **两种数据融合与转换**：地理信息系统通常同时包含栅格和矢量数据，显示结果时可合并两种数据，如地图应用常结合卫星图像和道路、建筑物等矢量数据，不同图层可叠加显示信息；矢量形式存储信息在发送到用户界面（如网页浏览器）前可能转换为栅格形式，原因一是即使禁用JavaScript的网页浏览器也能显示地图数据，二是防止终端用户提取和使用矢量数据；Google Maps和Bing Maps等地图服务提供API，允许用户创建包含特定应用数据叠加的专业地图显示。



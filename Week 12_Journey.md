本周阅读**Database-System-Concepts-7th-Edition**:PART FIVE STORAGE MANAGEMENT AND INDEXING,知识点总结如下：  
**Chapter 13 Data Storage Structures**(p587-621)  
>日期：5.13

# 第13章 数据存储结构
## 13.1 数据库存储架构
- 持久数据存储在非易失性存储设备（如磁盘或SSD）中，这些设备以块为单位读写数据。数据库处理的记录通常比块小，但记录属性可能很大。
- 多数数据库使用操作系统文件来存储记录，为确保高效访问和故障恢复，需考虑记录在文件中的存储方式。

## 13.2 文件组织
### 13.2.1 定长记录
- 数据库映射为操作系统维护的多个文件，文件逻辑上由记录序列组成，记录映射到磁盘块。文件逻辑上划分为固定长度的存储单元“块”，是存储分配和数据传输的基本单位，多数数据库默认块大小4 - 8KB 。
- 以大学数据库中教师记录文件为例，定义记录伪代码：
```
type instructor = record
    ID varchar (5);
    name varchar(20);
    dept_name varchar (20);
    salary numeric (8,2);
end
```
假设每个字符占1字节，numeric(8,2)占8字节，教师记录长53字节。简单方式是按顺序分配字节存储记录。
- **简单方法的问题**
    - 若块大小不是记录大小（53字节）的倍数，记录可能跨块，读写需两次块访问。
    - 删除记录困难，需填充删除记录空间或标记删除记录。
- **解决方法**
    - 为避免记录跨块，按块大小除以记录大小（取整）确定块中记录数，剩余字节闲置。
    - 删除记录时，可将后续记录前移（大量移动记录）或把文件最后记录移到删除记录空间。因插入比删除频繁，可留下删除记录空间，等待插入时重用。引入文件头（file header），存储首个删除记录地址，形成链表（自由列表free list ），插入新记录时使用头指针指向的记录，更新头指针指向下个可用记录，无空间时在文件末尾添加记录。

### 列存储（column - oriented storage）
将特定列的所有值一起存储，而非将特定行的所有属性一起存储，对分析查询处理很有效。

### 主内存数据库（main - memory databases）
一些应用需快速访问数据且数据量小，可将整个数据库存储在内存中。这类数据库存储整个数据库并优化内存数据结构、查询处理及其他算法，利用数据内存驻留特性。同时提到允许直接访问字节或缓存行的非易失性内存（存储类内存storage class memory ）正在开发中，主内存数据库架构可针对其进一步优化。   

## 13.2.2 变长记录
### 变长记录产生原因
- 数据库系统中出现变长记录，最常见原因是存在可变长度字段（如字符串），其他原因包括记录类型包含重复字段（如数组或多重集）以及同一文件中存在多种记录类型。

### 实现变长记录需解决的问题
1. **记录表示问题**：如何表示单个记录，使即使可变长度的单个属性也能轻松提取。通常，具有可变长度属性的记录表示包含两部分：初始固定长度信息部分（结构对同一关系的所有记录相同），以及可变长度属性内容。固定长度属性（如数值、日期、定长字符串）按需分配字节存储值；可变长度属性（如varchar类型）在记录初始部分用一对（偏移量, 长度）表示，偏移量表示属性数据在记录内起始位置，长度表示可变大小属性的字节长度，可变长度属性值在记录初始固定长度部分之后连续存储。
2. **块内存储问题**：如何在块内存储变长记录，以便轻松提取块内记录。常用**槽页结构（slotted - page structure）** 组织块内记录。每个块开头有一个头，包含以下信息：
    - 头中的记录条目数
    - 块内空闲空间结束位置
    - 一个数组，其条目包含每个记录的位置和大小
实际记录从块末尾开始连续分配，块内空闲空间在头数组最后一个条目和第一个记录之间。插入记录时，在空闲空间末尾为其分配空间，并在头中添加包含其大小和位置的条目；删除记录时，释放其所占空间，将其条目设置为已删除（如大小设为 - 1 ），并移动删除记录之前的记录，以占用删除产生的空闲空间，同时适当更新头中的空闲空间结束指针。记录可在块内空间允许的情况下增长或缩小。槽页结构要求指针不直接指向记录，而是指向头中包含记录实际位置的条目，这种间接方式可防止块内空间碎片化，同时支持指向记录的间接指针。

### 空值位图（null bitmap）
用于指示记录的哪些属性具有空值。例如在教师记录示例中，若有四个属性，空值位图可能占用1字节，每个位对应一个属性，若某属性为空值，则对应位设为1 。在某些表示中，空值位图存储在记录开头，对于空值属性，不存储数据（值、偏移量/长度），可节省存储空间，但提取记录属性时需额外处理。

## 13.2.3 大对象存储
### 大对象存储方式
- 数据库常存储比磁盘块大得多的数据，如SQL支持的blob和clob类型，分别存储二进制和字符大对象。许多数据库内部限制记录大小不超过块大小，但允许记录逻辑上包含大对象，实际将大对象与记录的其他（短）属性分开存储，在包含大对象的记录中存储指向该对象的（逻辑）指针。大对象可存储为数据库管理的文件系统区域中的文件，或存储为数据库内管理的文件结构。在后一种情况下，可选择使用B⁺树文件组织表示数据库内的大对象，以实现对对象内任意位置的高效访问，支持读取整个对象、指定字节范围以及插入和删除对象部分内容。

### 大对象存储的性能问题
- 通过数据库接口访问大对象的效率是一个问题；许多企业定期创建数据库备份（“数据库转储”），在数据库中存储大对象会大幅增加数据库转储大小。因此许多应用选择将大对象（如视频数据）存储在数据库外的文件系统中，在数据库记录中存储文件名（通常是文件系统路径）作为属性。但这种方式可能导致数据库中的文件名指向不存在的文件（如文件被删除），造成外键约束违规，且数据库授权控制不适用于存储在文件系统中的数据。部分数据库支持与文件系统集成，以确保满足约束（如数据库有指向文件的指针时阻止删除文件）并实施访问授权，如Oracle通过其SecureFiles和Database File System功能支持这种集成。

## 13.3 文件中记录的组织
### 堆文件组织（Heap file organization）
记录可存储在关系对应的文件中的任何有空间的位置，放置后通常不移动。插入记录时，一种选择是始终添加在文件末尾，但记录删除后，利用释放的空间存储新记录更合理。数据库系统需能高效找到有空闲空间的块，多数数据库使用称为**空闲空间映射（free - space map）** 的高效数据结构跟踪哪些块有空闲空间存储记录。空闲空间映射通常由一个数组表示，关系中的每个块对应数组中的一个条目，每个条目表示一个分数f ，表示块中至少有分数f 的空间空闲。例如在PostgreSQL中，一个条目为1字节，存储的值需除以256得到空闲空间分数。数组存储在文件中，根据需要将其块提取到内存。每当记录插入、删除或大小改变，若占用分数变化足以影响条目值，就在空闲空间映射中更新该条目。 

### 顺序文件组织（Sequential file organization）
记录根据每个记录的“搜索键”值按顺序存储。 

### 多表聚簇文件组织（Multitable clustering file organization）
通常每个关系使用单独文件或文件集存储记录，但在多表聚簇文件组织中，多个不同关系的记录存储在同一文件中，甚至在文件的同一块内，以降低某些连接操作的成本。 

### B⁺树文件组织（B⁺-tree file organization）
传统顺序文件组织虽支持有序访问，但在大量插入、删除和更新操作下，有序访问效率会受影响。B⁺树文件组织与B⁺树索引结构相关，即使存在大量插入、删除或更新操作，仍能为记录提供高效有序访问，还支持基于搜索键高效访问特定记录。 

### 散列文件组织（Hashing file organization）
对每个记录的某个属性计算散列函数，散列函数结果指定记录应放置在文件的哪个块中 。   

## 13.3.2 顺序文件组织
### 定义与原理
顺序文件（sequential file）旨在基于某个搜索键（search key，可为任意属性或属性集，不必是主键或超键）对记录进行高效排序处理。为实现按搜索键顺序快速检索记录，通过指针将记录链接起来，每个记录中的指针指向下一个按搜索键顺序的记录。并且，为减少顺序文件处理中的块访问次数，尽量按搜索键顺序物理存储记录。

### 示例
以大学数据库中教师记录为例，图13.7展示了使用ID作为搜索键，按搜索键顺序存储的教师记录顺序文件。顺序文件组织允许按排序顺序读取记录，这对显示目的以及某些查询处理算法（如第15章将学习的算法）很有用。

### 插入与删除操作
- **插入规则**：
    1. 定位文件中按搜索键顺序位于要插入记录之前的记录。
    2. 若该记录所在块内有空闲记录（删除后留下的空间），则在该位置插入新记录；否则，将新记录插入溢出块（overflow block）。无论哪种情况，都要调整指针，使记录按搜索键顺序链接起来 。
- **删除操作**：可通过指针链管理删除操作。

### 维护问题
随着记录的插入和删除，难以维持物理顺序，因为单次插入或删除可能导致大量记录移动，成本高昂。若相对较少记录需存储在溢出块中，上述插入方法效果尚可。但随着时间推移，搜索键顺序与物理顺序可能完全脱节，导致顺序处理效率大幅降低，此时需对文件进行重组（reorganized），使其恢复物理顺序。重组成本高，需在系统负载低时进行，重组频率取决于新记录插入频率。在插入极少的极端情况下，可始终保持文件物理排序，此时图13.7中的指针字段可省略。B⁺树文件组织（在14.4.1节介绍）即使在大量插入、删除和更新操作下，也能提供高效有序访问，且无需昂贵的重组操作。

## 13.3.3 多表聚簇文件组织
### 定义
多表聚簇文件组织（Multitable clustering file organization）是一种将两个或多个关系的相关记录存储在每个块中的文件组织方式。簇键（cluster key）是定义哪些记录存储在一起的属性。

### 优势
以大学数据库中department和instructor关系的自然连接查询为例：
```sql
select dept_name, building, budget, ID, name, salary
from department natural join instructor;
```
此查询需连接department和instructor关系。理想情况下借助索引定位记录（索引将在第14章讨论），但记录仍需从磁盘传输到主内存。若每个记录在不同块，查询需为每个记录进行一次块读取。采用多表聚簇文件组织，特定dept_name的所有instructor元组存储在对应department元组附近，两个关系基于dept_name键聚簇。读取department关系的元组时，包含该元组的整个块从磁盘复制到主内存，由于对应的instructor元组存储在附近，该块包含处理查询所需的instructor关系元组，可加速某些连接查询。

### 劣势
但这种组织方式可能降低其他类型查询的处理速度。例如：
```sql
select * from department;
```
与每个关系存储在单独文件的方案相比，此查询需更多块访问，因为每个块中包含的department记录显著减少。为高效定位特定块内department关系的所有元组，可使用指针链接该关系的所有记录，但使用指针链不会减少读取的块数。是否使用多表聚簇取决于数据库设计者认为最频繁的查询类型，合理使用可显著提高查询处理性能。Oracle数据库系统支持多表聚簇，可使用`create cluster`命令创建簇并指定簇键，也可使用`create table`命令的扩展指定关系存储在特定簇中并使用特定属性作为簇键，从而将多个关系分配到一个簇。

## 13.3.4 分区（Partitioning）
许多数据库允许将关系中的记录划分为单独存储的较小关系，即表分区（table partitioning），通常基于属性值进行。例如，会计数据库中transaction关系的记录可按年份分区为transaction_2018、transaction_2019等较小关系。查询可基于transaction关系编写，但会转换为对按年划分的关系的查询。大多数访问是对当前年份记录的访问，并包含基于年份的选择条件。查询优化器可重写此类查询，仅访问请求年份对应的较小关系，避免读取其他年份的记录。例如：
```sql
select * from transaction where year = 2019
```
此查询仅访问transaction_2019关系，忽略其他关系，而无选择条件的查询将读取所有关系。一些操作（如为记录查找空闲空间）的成本随关系大小增加而增加，分区通过减小每个关系的大小，有助于降低此类开销。分区还可用于将关系的不同部分存储在不同位置 。   

## 13.4 数据字典存储
### 元数据概念
关系数据库系统需维护关于关系的数据，如关系模式等，这类“关于数据的数据”称为元数据（metadata） 。关系模式及其他关于关系的元数据存储在数据字典（data dictionary）或系统目录（system catalog）中。

### 数据字典存储信息
- **关系相关**：
    - 关系名称
    - 每个关系的属性名称
    - 属性的域和长度
    - 在数据库上定义的视图名称及其定义
    - 完整性约束（如键约束）
- **用户相关**：
    - 用户名称、用户默认模式、用于认证用户的密码或其他信息
    - 每个用户的授权信息
- **其他**：
    - 关于关系和属性的统计和描述性数据，如每个关系的元组数、每个属性的不同值数量
    - 关系的存储组织（堆、顺序、散列等）及存储位置：
        - 若关系存储在操作系统文件中，记录包含每个关系的文件名称
        - 若数据库将所有关系存储在单个文件中，可能在链表等数据结构中记录包含每个关系记录的块
    - 关于每个关系上的索引信息：
        - 索引名称
        - 被索引的关系名称
        - 索引定义所基于的属性
        - 索引类型

### 存储方式
这些元数据信息实际上构成一个小型数据库。一些数据库系统使用特殊用途的数据结构和代码存储此类元数据，但通常更倾向于将关于数据库的数据作为数据库自身的关系来存储，这样可简化系统整体结构，并利用数据库的强大功能快速访问系统数据。系统设计者需选择如何用关系表示系统元数据。数据字典常以非规范化形式存储以实现快速访问，例如Index_metadata关系中的index_attributes属性可能包含一个或多个属性的列表，可表示为字符串（如“dept_name, building”），该关系可能不满足第一范式，但这种表示可能更便于访问。  
>日期：5.15

## 13.5 数据库缓冲区
### 缓冲区与缓冲区管理器
- 缓冲区（buffer）是主内存中用于存储磁盘块副本的部分。磁盘上始终保留每个块的副本，但磁盘上的副本可能比缓冲区中的版本旧。负责分配缓冲区空间的子系统称为缓冲区管理器（buffer manager） 。
- 数据库系统中的程序需要磁盘块时，会向缓冲区管理器发出请求。若块已在缓冲区中，缓冲区管理器将块在主内存中的地址传递给请求者；若块不在缓冲区中，缓冲区管理器首先在缓冲区中为该块分配空间，必要时淘汰其他块以腾出空间。只有自上次写入磁盘后被修改过的淘汰块才会被写回磁盘，然后缓冲区管理器从磁盘读取请求的块到缓冲区，并将块在主内存中的地址传递给请求者。缓冲区管理器的内部操作对发出磁盘块请求的程序是透明的。

### 缓冲区替换策略（Buffer replacement strategy）
当缓冲区没有剩余空间时，在读取新块之前必须淘汰（evict）一个块。大多数操作系统使用最近最少使用（least recently used, LRU）方案，即最近最少被引用的块被写回磁盘并从缓冲区中移除。对于数据库应用，这种简单方法可进一步改进。

### 固定块（Pinned blocks）
- 一个块被读入缓冲区后，数据库进程可从缓冲内存中读取块内容。但在读取过程中，若并发进程淘汰该块并替换为其他块，正在读取旧块内容的进程将看到错误数据；若块在被淘汰时正在被写入，写入进程可能会损坏替换块的内容。
- 因此，进程从缓冲块读取数据前，需执行固定（pin）操作以确保块不会被淘汰，缓冲区管理器不会淘汰固定块。进程读取完数据后，应执行取消固定（unpin）操作，允许在需要时淘汰该块。数据库代码应谨慎编写以避免固定过多块，否则若缓冲区中的所有块都被固定，将无法淘汰任何块，也无法将其他块读入缓冲区，导致数据库无法进行进一步处理。
- 多个进程可从缓冲区中的块读取数据，每个进程在访问数据前需执行pin操作，完成访问后执行unpin操作。只有当所有执行过pin操作的进程都执行了unpin操作，块的固定计数（pin count）为0时，该块才能被淘汰。

### 缓冲区的共享锁与排他锁（Shared and Exclusive Locks on Buffer）
- 向页面添加或删除元组的进程可能需要移动页面内容，在此期间，其他进程不应读取页面内容，因为可能会不一致。数据库缓冲区管理器允许进程对缓冲区获取共享锁和排他锁。
- **锁定规则**：
    - 任意数量的进程可同时对一个块持有共享锁。
    - 一次只允许一个进程获得排他锁，且当一个进程持有排他锁时，其他进程不能对该块持有共享锁，即只有在没有其他进程对缓冲块持有锁时，才能授予排他锁。
    - 若一个进程在块已被共享锁或排他锁锁定时请求排他锁，请求将被挂起，直到所有先前的锁被释放。
    - 若一个进程在块未被锁定或已被共享锁锁定时请求共享锁，可能会被授予锁；但如果另一个进程持有排他锁，则只有在排他锁被释放后才会授予共享锁。
- **锁的获取与释放**：
    - 进程在对块执行任何操作前，必须先固定该块，然后获取锁，并在取消固定块之前释放锁。
    - 从缓冲块读取数据前，进程必须获取共享锁，读取完数据后释放锁。
    - 更新缓冲块内容前，进程必须获取排他锁，更新完成后释放锁。
这些规则确保一个块在被另一个进程读取时不能被更新，反之亦然，以保证缓冲区访问的安全性，但要保护数据库系统免受并发访问问题的影响，还需采取进一步措施。

## 13.5.2 缓冲区替换策略
### LRU策略及数据库系统的改进
- **LRU策略**：在操作系统中，最近最少使用（LRU，Least Recently Used ）方案是一种可接受的缓冲区块替换策略，它基于过去块的引用模式预测未来，认为最近最少被引用的块在未来被引用的可能性较低，会将其写回磁盘并从缓冲区移除。
- **数据库系统的优势**：数据库系统相比操作系统能更准确预测未来块引用模式。用户对数据库系统的请求涉及多个步骤，数据库系统常能通过分析执行用户请求操作所需的步骤，提前确定需要哪些块，即数据库系统可能拥有关于短期未来的信息 。

### toss - immediate策略和MRU策略
以`select * from instructor natural join department;`查询为例：
- **toss - immediate策略**：假设处理此请求的策略如伪代码（图13.13）所示，且两个关系存储在单独文件中。对于instructor关系，一旦处理完一个块中的所有元组，该块在主存中就不再需要，即使它最近被使用过。缓冲区管理器应在处理完最后一个instructor元组后，立即释放该块占用的空间，这种缓冲区管理策略称为toss - immediate策略。
- **MRU策略**：对于包含department元组的块，需要为instructor关系的每个元组检查每个department块。处理完一个department块后，知道在处理完所有其他department块之前不会再次访问该块。所以，最近使用的department块将是最后一个被再次引用的块，而最少使用的department块是下一个将被引用的块。在这种情况下，最优的块替换策略是最近使用（MRU，Most Recently Used ）策略，即如果必须从缓冲区中移除一个department块，MRU策略会选择最近使用的块（块在使用时不符合替换条件）。为使MRU策略在此例中正确工作，系统必须固定当前正在处理的department块，处理完最后一个department元组后取消固定，使其成为最近使用的块。

### 其他影响缓冲区替换策略的因素
- **利用统计信息**：缓冲区管理器除利用系统对正在处理请求的了解外，还可使用关于请求引用特定关系概率的统计信息。例如，数据字典是数据库中最常访问的部分之一，因为每个查询的处理都需要访问数据字典，所以缓冲区管理器应尽量避免从主存中移除数据字典块，除非有其他因素要求这么做。在第14章讨论的文件索引，由于文件索引的访问频率可能高于文件本身，一般情况下，如果有其他可用选项，缓冲区管理器不应从主存中移除索引块。
- **并发控制的影响**：如果系统同时处理多个用户的请求，并发控制子系统（第18章）可能需要延迟某些请求以确保数据库一致性。如果缓冲区管理器从并发控制子系统获得指示哪些请求被延迟的信息，它可以利用这些信息改变块替换策略。具体来说，活动（未延迟）请求所需的块可以保留在缓冲区中，而牺牲延迟请求所需的块。
- **故障恢复的约束**：故障恢复子系统（第19章）对块替换施加严格约束。如果一个块已被修改，缓冲区管理器不允许将缓冲区中块的新版本写回磁盘，因为这会破坏旧版本。相反，块管理器在写出一个块之前必须先获得故障恢复子系统的许可。故障恢复子系统可能要求在授予缓冲区管理器写出请求块的许可之前，强制输出某些其他块。

## 13.5.3 写操作重排序与恢复
### 文件系统写操作重排序问题
数据库缓冲区允许在内存中执行写操作，并在以后的某个时间输出到磁盘，且写操作的输出顺序可能与执行顺序不同，文件系统也经常对写操作进行重排序。然而，这种重排序在系统崩溃时可能导致磁盘上的数据不一致。例如，假设文件系统使用链表跟踪文件的块，在链表末尾插入新节点时，先写入新节点的数据，然后更新前一个节点的指针。如果写操作被重排序，先更新指针，且在写入新节点之前系统崩溃，那么节点的内容将是磁盘上之前的任意内容，从而导致数据结构损坏。

### 解决方法
- **文件系统一致性检查**：早期的文件系统在系统重启时执行文件系统一致性检查，以确保数据结构一致。如果不一致，需采取额外步骤恢复一致性。但这些检查会导致系统崩溃后重启时的长时间延迟，且随着磁盘系统容量增加，延迟问题变得更严重。
- **日志磁盘（log disk）**：现代文件系统通常分配一个磁盘来按写操作执行顺序存储写操作日志，这种磁盘称为日志磁盘。对于每个写操作，日志包含要写入的块号和要写入的数据。对日志磁盘的所有访问都是顺序的，基本上消除了寻道时间，并且可以一次写入几个连续的块，使写入日志磁盘的速度比随机写入快几倍。当实际位置的写操作完成后，写操作可以重新排序以最小化磁盘臂移动。如果在对实际磁盘位置的某些写操作完成之前系统崩溃，系统重启时会读取日志磁盘，找到未完成的写操作并执行它们。完成写操作后，从日志磁盘中删除记录。支持上述日志磁盘的文件系统称为日志文件系统（journaling file systems ）。日志文件系统即使没有单独的日志磁盘，也可以将数据和日志存储在同一磁盘上实现，这样做虽降低了成本，但性能会有所下降。大多数现代文件系统实现日志记录，并在写入文件系统元数据（如文件分配信息）时使用日志磁盘，日志文件系统允许快速重启，而无需进行文件系统一致性检查。
- **数据库系统的日志机制**：应用程序执行的写操作通常不会写入日志磁盘，数据库系统会实现自己的日志形式（将在第19章学习），以确保在发生故障时，即使写操作被重排序，也能安全恢复数据库内容。

## 13.6 列存储
### 行存储与列存储对比
- **行存储**：传统数据库将元组的所有属性存储在一个记录中，元组存储在文件中，这种存储布局称为行存储（row - oriented storage）。
- **列存储**：列存储（column - oriented storage，也称为columnar storage）中，关系的每个属性单独存储，来自连续元组的属性值存储在文件中的连续位置。例如，instructor关系在列存储中，每个属性将被分开存储。在最简单的列存储形式中，每个属性存储在一个单独的文件中，并且每个文件会被压缩以减小其大小。

### 列存储的优缺点
- **缺点**：如果查询需要访问表中第i行的全部内容，则需要检索每个列中第i个位置的值来重建该行。因此，列存储的缺点是获取单个元组的多个属性需要多次I/O操作，所以它不适合从关系的少数行中获取多个属性的查询。
- **优点**：
    - **减少I/O**：当查询只需要访问具有大量属性的关系中的少数属性时，在列存储中，无需将其余属性从磁盘读取到内存。相比之下，在行存储中，不相关的属性会从磁盘读取到内存。I/O的减少可显著降低查询执行成本。
    - **提高CPU缓存性能**：当查询处理器获取特定属性的内容时，现代CPU架构会将多个连续字节（称为缓存行）从内存读取到CPU缓存中。如果这些字节稍后被访问，在缓存中的访问速度比从主内存读取要快得多。但如果这些相邻字节包含查询不需要的属性值，将它们读取到缓存中会浪费内存带宽并占用本可用于其他数据的缓存空间。列存储不会出现这个问题，因为相邻字节来自同一列，并且数据分析查询通常会连续访问这些值。
    - **增强压缩效果**：将相同类型的值存储在一起与压缩行格式存储的数据相比，显著提高了压缩效率。在行格式存储中，相邻属性类型不同，降低了压缩效率。压缩可显著减少从磁盘检索数据所需的时间，这通常是许多查询中成本最高的部分。如果压缩文件存储在内存中，内存存储空间也会相应减少，这一点尤其重要，因为主内存比磁盘存储贵得多。
    - **支持向量处理**：许多现代CPU架构支持向量处理（vector processing），它允许对数组的多个元素并行应用CPU操作。按列存储数据允许对诸如将属性与常量进行比较等操作进行向量处理，这对于在关系上应用选择条件很重要。向量处理还可用于并行计算多个值的聚合，而不是逐个聚合值。

### 列存储（Column - Oriented Storage）
- **定义与特点**：关系的每个属性单独存储，来自连续元组的属性值存储在文件中的连续位置，常将每个属性存储在单独文件并压缩 。与行存储（row - oriented storage）将元组所有属性存储在一个记录中不同，列存储适用于数据分析查询。
- **优点**
    - **减少I/O**：查询只需访问少数属性时，无需读取其余属性，降低查询执行成本。
    - **提高CPU缓存性能**：相邻字节来自同一列，避免缓存带宽浪费和空间占用。
    - **增强压缩效果**：相同类型值一起存储提高压缩效率，减少数据检索时间和内存占用。
    - **支持向量处理**：利于并行执行操作，如属性与常量比较、多值聚合 。
- **缺点及不适用场景**
    - **元组重建成本高**：从单独列重建元组开销大，事务处理中常见元组重建，不适合此类场景。
    - **元组删除和更新成本高**：压缩表示中删除或更新单个元组需重写整个压缩单元，事务处理中频繁更新删除操作会导致高成本，数据仓库系统多支持插入新元组和批量删除旧元组，适合列存储。 
    - **解压缩成本高**：从压缩表示获取数据需解压缩，事务处理查询只需获取少量记录，顺序访问解压缩大量无关记录成本高，数据分析查询连续访问记录多，解压缩时间浪费少，但也需跳过不满足条件记录属性值以减少磁盘I/O 。
- **改进与应用**
    - 允许从文件多个点开始解压缩，跳过文件前面部分，如每10,000个值重新开始压缩并记录每组起始位置，便于访问特定值 。
    - ORC和Parquet是大数据处理中常用的列文件表示。ORC将行表示转换为列表示，把几百兆字节的元组序列分解为称为stripe的列表示，每个stripe约250兆字节，包含索引数据和行数据，索引可快速访问元组或跳过不满足条件的元组组 。
    - 一些列存储系统允许经常一起访问的列组存储在一起，提供从纯列存储到纯行存储的多种选择，取决于查询负载 。
    - 行存储系统可通过逻辑分解关系获取列存储部分优势，但存在空间浪费问题；部分数据库系统在磁盘块内使用列存储表示数据，兼具内存访问和缓存使用优势，不具备压缩优势；SAP HANA等数据库支持两种存储系统（行存储用于事务处理，列存储用于数据分析），称为混合行/列存储（hybrid row/column stores） ；有些应用在行存储中存储事务数据，定期复制到使用列存储的数仓 。

### 内存数据库中的存储组织（Storage Organization in Main - Memory Databases）
- **背景与优势**：如今主存容量大且成本低，许多组织数据库可完全存入内存。通过为数据库缓冲区分配大量内存，可将整个数据库加载到缓冲区，避免读取数据的磁盘I/O操作（更新块仍需写回磁盘持久化），性能优于仅部分数据库能放入缓冲区的情况 。
- **优化措施**
    - **记录访问优化**：基于磁盘的数据库中，记录存储在块中，访问记录指针需检查块是否在缓冲区等操作，消耗大量CPU周期；内存数据库中，可在内存中保持指向记录的直接指针，访问记录是高效的内存指针遍历，前提是记录不移动，避免了加载和淘汰操作 。若记录存储在块内的分槽页结构中，记录可能因其他记录删除或调整大小而移动，无法使用直接指针，可通过分槽页头间接访问，或数据库直接在主存分配记录并避免因其他记录更新导致移动，同时要处理可变大小记录插入删除导致的内存碎片化问题，可采用合适内存管理方案或定期内存压缩 。
    - **列存储优化**：内存中使用列存储方案，一列所有值可存储在连续内存位置，若关系有追加操作，为避免重新分配现有数据，可将列的逻辑数组划分为多个物理数组，通过间接表存储指向物理数组的指针，查找逻辑数组第i个元素时，先通过间接表定位包含该元素的物理数组，再在其中计算并查找偏移量 。 

### 总结（Summary）
- **文件逻辑组织**：文件可逻辑组织为映射到磁盘块的记录序列，一种方式是用多个文件，每个文件存储固定长度记录；另一种是让文件能容纳多种长度记录，分槽页方法广泛用于处理磁盘块内可变长度记录 。
- **数据块分配**：数据在磁盘存储和主内存间以块为单位传输，合理分配文件记录到块，使单个块包含相关记录，可减少磁盘访问，提升数据库性能，因磁盘访问常是数据库性能瓶颈 。 
- **数据字典功能**：数据字典（系统目录）用于跟踪元数据，包括关系名、属性名和类型、存储信息、完整性约束和用户信息 。 
- **缓冲区管理作用**：减少磁盘访问的一种方法是尽量在主内存中保留更多块，因无法将所有块存于主内存，需管理主内存中块存储可用空间，缓冲区是主内存中存储磁盘块副本的部分，负责分配缓冲区空间的子系统是缓冲区管理器 。 
- **列存储适用场景**：列存储系统在许多数据仓库应用中表现良好 。

> 日期：5.17课后习题选做

### 13.9
#### a. 
在可变长度字段中，如果值为null，偏移（offset）字段和长度（length）字段都应存储0。因为null值表示该字段没有实际的数据存储，所以不存在相对于记录起始位置的偏移，即偏移量为0；同时，由于没有实际数据，其占用空间长度也为0。

#### b. 
可以修改记录表示。我们可以保持现有的null位图不变，它用于标识属性是否为null 。对于非null属性，按照常规方式存储其值、偏移量和长度等信息。对于null属性，除了在null位图中占用一位来标识其为null外，不额外为其存储值、偏移量和长度等信息。这样，null属性的唯一开销就是null位图中的单个比特位。

### 13.10
数据库中数据在磁盘存储和主内存间以块为单位传输。如果记录分配不合理，使得需要访问的多个相关记录分散在不同的块中，那么每次访问这些记录时，都需要进行一次磁盘I/O操作来读取相应的块。而磁盘I/O操作相对较慢，是数据库系统性能的瓶颈之一。相反，如果能合理地将相关记录分配到同一个块中，那么在访问这些相关记录时，一次磁盘I/O操作就可以读取到多个所需记录，大大减少了磁盘I/O的次数，从而显著提升数据库系统的性能。所以记录到块的分配对数据库系统性能影响很大。

### 13.11
#### a. 每个关系存储在一个文件中
- **优点**
    - **管理方便**：每个关系独立存储在一个文件中，在对关系进行诸如备份、恢复、维护等管理操作时，非常直观和便捷，不会影响到其他关系。例如，当需要对某个关系进行数据修复时，只需要针对该关系所在文件操作即可。
    - **数据隔离性好**：不同关系的数据分别存储在不同文件，相互之间具有良好的隔离性。一个关系文件出现损坏、错误等问题时，不会影响到其他关系的数据完整性和可用性。
- **缺点**
    - **空间利用率低**：每个文件都需要预留一定的空间用于文件管理等开销，并且如果关系本身数据量较小，文件中可能会存在大量未使用空间，造成存储空间的浪费。
    - **多关系查询性能差**：当执行涉及多个关系的连接查询等操作时，需要同时读取多个文件，增加了磁盘I/O的次数，导致查询性能下降。

#### b. 多个关系（甚至整个数据库）存储在一个文件中
- **优点**
    - **空间利用率高**：可以根据关系数据的实际情况，灵活地在一个文件内分配空间，避免了单个关系文件中可能出现的空间浪费问题，提高了整体存储空间的利用率。
    - **连接查询性能提升**：对于经常需要进行连接操作的多个关系，如果它们存储在同一个文件中，在执行连接查询时，可以减少磁盘I/O操作，因为不需要在多个文件之间切换读取，从而提升查询效率。
- **缺点**
    - **管理复杂**：多个关系的数据混合存储在一个文件中，使得对数据的管理（如数据的定位、修改、删除等）变得更加复杂。例如，要修改某个关系的数据，可能需要在文件中仔细查找和区分相关数据。
    - **数据安全性降低**：一旦这个文件出现问题（如文件损坏、遭受病毒攻击等），会影响到多个关系的数据，造成较大范围的数据丢失或错误，数据恢复难度也相对较大。

### 13.12
在顺序文件组织中，使用溢出块有以下原因：虽然当前可能只有一个溢出记录，但未来可能会有更多的溢出记录产生。如果不使用溢出块，当新的溢出记录到来时，就需要频繁地调整文件的结构来适应新记录的存储，这会带来较大的开销，包括对文件索引、指针等的修改操作。而使用溢出块，可将溢出记录集中存储在专门的溢出块中，通过合理的链接（如链表链接）或索引机制与主文件相关联。这样，在后续有更多溢出记录时，只需要在溢出块中进行存储管理，而不需要对主文件结构进行频繁改动，便于对溢出记录进行统一管理和维护，提高了文件组织的稳定性和可扩展性。 

### 13.13
假设原始的Index_metadata关系模式为Index_metadata(index_name, relation_name, index_type, index_attributes) ，其中index_attributes可能包含多个属性，导致该关系不满足第一范式。

规范化后的关系模式：
- Index_metadata_1(index_name, relation_name, index_type)
- Index_metadata_2(index_name, index_attribute)

使用规范化版本性能变差的原因：在查询索引相关信息时，非规范化的Index_metadata关系可以直接获取到索引名称、所属关系、索引类型以及索引所基于的属性等所有信息。而规范化后，若要获取完整的索引相关信息，需要通过index_name对Index_metadata_1和Index_metadata_2进行连接操作。连接操作会增加系统的计算开销，特别是在频繁查询索引信息的场景下，会导致查询性能下降，因为原本一次查询就能获取的信息，现在需要通过多表连接来获取。

### 13.14
可以采用以下方法来选择从缓冲区淘汰的块：
1. **计算性价比指标**：定义一个指标来衡量对象的性价比，公式为：
 $\[
\text{性价比} = \frac{\text{最近}n\text{秒内引用次数} / \text{对象大小}}{\text{读取成本}}
\]$ 
这个指标综合考虑了对象的使用频率（最近n秒内引用次数）、占用空间大小（对象大小）以及读取成本。性价比越低，说明在相同的资源占用（空间和读取成本）情况下，该对象的使用频率相对较低，可作为优先淘汰的候选对象。
2. **设置淘汰阈值**：根据缓冲区的使用情况和系统性能要求，设置一个淘汰阈值。定期（例如每隔一段时间t）计算缓冲区中每个对象的性价比，将性价比低于阈值的对象列入可淘汰列表。
3. **考虑对象重要性**：对于一些重要的对象（例如系统关键数据对应的块、经常被并发访问的块等），可以设置特殊标记或权重，即使其性价比低，也不轻易淘汰。可以根据对象的使用场景和业务需求，人工或通过系统规则来定义哪些对象属于重要对象。   
